<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MakeselfMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">makeself-maven-plugin</a> &gt; <a href="index.source.html" class="el_package">com.hazendaz.maven.makeself</a> &gt; <span class="el_source">MakeselfMojo.java</span></div><h1>MakeselfMojo.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2011-2023 the original author or authors.
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
 *    as published by the Free Software Foundation; either version 2
 *    of the License, or (at your option) any later version.
 *
 *    You may obtain a copy of the License at
 *
 *       https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 */
package com.hazendaz.maven.makeself;

import com.google.common.base.Joiner;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
import org.apache.commons.io.FilenameUtils;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.artifact.repository.ArtifactRepository;
import org.apache.maven.artifact.resolver.ArtifactResolutionRequest;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.Component;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.MavenProjectHelper;
import org.apache.maven.repository.RepositorySystem;

/**
 * The Class MakeselfMojo.
 */
@Mojo(name = &quot;makeself&quot;, defaultPhase = LifecyclePhase.VERIFY, requiresProject = false)
<span class="nc" id="L62">public class MakeselfMojo extends AbstractMojo {</span>

    /**
     * isWindows is detected at start of plugin to ensure windows needs.
     */
<span class="nc" id="L67">    private static final boolean WINDOWS = System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);</span>

    /**
     * The path to git which is left blank unless portable git is used.
     */
<span class="nc" id="L72">    private String gitPath = &quot;&quot;;</span>

    /**
     * archive_dir is the name of the directory that contains the files to be archived.
     */
    @Parameter(defaultValue = &quot;makeself&quot;, property = &quot;archiveDir&quot;, required = true)
    private String archiveDir;

    /**
     * file_name is the name of the archive to be created.
     */
    @Parameter(defaultValue = &quot;makeself.sh&quot;, property = &quot;fileName&quot;, required = true)
    private String fileName;

    /**
     * label is an arbitrary text string describing the package. It will be displayed while extracting the files.
     */
    @Parameter(defaultValue = &quot;Makeself self-extractable archive&quot;, property = &quot;label&quot;, required = true)
    private String label;

    /**
     * startup_script is the command to be executed from within the directory of extracted files. Thus, if you wish to
     * execute a program contained in this directory, you must prefix your command with './'. For example, './program'
     * will be fine.
     */
    @Parameter(defaultValue = &quot;./makeself.sh&quot;, property = &quot;startupScript&quot;, required = true)
    private String startupScript;

    /**
     * extension is for type of fileName being created. It defaults to 'sh' for backwards compatibility. Makeself
     * defines 'run' as its default, therefore when using 'run', set extension to 'run'. This extension is used when
     * attaching resulting artifact to maven.
     *
     * @since 1.5.0
     */
    @Parameter(defaultValue = &quot;sh&quot;, property = &quot;extension&quot;)
    private String extension;

    /**
     * classifier is for fileName being created to allow for more than one. If not defined, multiple artifacts will all
     * be installed to same m2 location. The artifact will take on the project artifact where classfier is the physical
     * name attribute you which to create for the fileName.
     *
     * @since 1.5.0
     */
    @Parameter(property = &quot;classifier&quot;)
    private String classifier;

    /**
     * inline script allows user to skip strict verification of startup script for cases where script is defined
     * directly such as 'echo hello' where 'echo' is a 'program' to run and 'hello' is one of many 'script arguments'.
     * Behaviour of makeself plugin prior to 1.5.0 allowed for this undocumented feature which is further allowed and
     * shown as an example in makeself. Verification therefore checks that both startupScript and scriptArgs exist only.
     *
     * @since 1.5.1
     */
    @Parameter(property = &quot;inlineScript&quot;)
    private boolean inlineScript;

    /**
     * script_args are additional arguments for startup_script passed as an array.
     *
     * &lt;pre&gt;
     * {@code
     * &lt;scriptArgs&gt;
     *   &lt;scriptArg&gt;arg1&lt;/scriptArg&gt;
     *   &lt;scriptArg&gt;arg2&lt;/scriptArg&gt;
     * &lt;/scriptArgs&gt;
     * }
     * &lt;/pre&gt;
     */
    @Parameter(property = &quot;scriptArgs&quot;)
    private List&lt;String&gt; scriptArgs;

    /**
     * cleanup_script_args are additional arguments for cleanup_script passed as an array.
     *
     * &lt;pre&gt;
     * {@code
     * &lt;cleanupArgs&gt;
     *   &lt;cleanupArg&gt;arg1&lt;/cleanupArg&gt;
     *   &lt;cleanupArg&gt;arg2&lt;/cleanupArg&gt;
     * &lt;/cleanupArg&gt;
     * }
     * &lt;/pre&gt;
     */
    @Parameter(property = &quot;cleanupArgs&quot;)
    private List&lt;String&gt; cleanupArgs;

    /**
     * --version | -v : Print out Makeself version number and exit
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;version&quot;)
    private Boolean version;

    /**
     * --help | -h : Print out this help message and exit (exit is custom to makeself maven plugin).
     */
    @Parameter(property = &quot;help&quot;)
    private Boolean help;

    /**
     * --tar-quietly : Suppress verbose output from the tar command.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;tarQuietly&quot;)
    private Boolean tarQuietly;

    /**
     * --quiet | -q : Do not print any messages other than errors.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;quiet&quot;)
    private Boolean quiet;

    /**
     * --gzip : Use gzip for compression (the default on platforms on which gzip is commonly available, like Linux).
     */
    @Parameter(property = &quot;gzip&quot;)
    private Boolean gzip;

    /**
     * --bzip2 : Use bzip2 instead of gzip for better compression. The bzip2 command must be available in the command
     * path. It is recommended that the archive prefix be set to something like '.bz2.run', so that potential users know
     * that they'll need bzip2 to extract it.
     */
    @Parameter(property = &quot;bzip2&quot;)
    private Boolean bzip2;

    /**
     * --bzip3 : Use bzip3 instead of gzip for better compression. The bzip3 command must be available in the command
     * path. It is recommended that the archive prefix be set to something like '.bz3.run', so that potential users know
     * that they'll need bzip3 to extract it.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;bzip3&quot;)
    private Boolean bzip3;

    /**
     * --pbzip2 : Use pbzip2 instead of gzip for better and faster compression on machines having multiple CPUs. The
     * pbzip2 command must be available in the command path. It is recommended that the archive prefix be set to
     * something like '.pbz2.run', so that potential users know that they'll need bzip2 to extract it.
     */
    @Parameter(property = &quot;pbzip2&quot;)
    private Boolean pbzip2;

    /**
     * --xz : Use xz instead of gzip for better compression. The xz command must be available in the command path. It is
     * recommended that the archive prefix be set to something like '.xz.run' for the archive, so that potential users
     * know that they'll need xz to extract it.
     */
    @Parameter(property = &quot;xz&quot;)
    private Boolean xz;

    /**
     * --lzo : Use lzop instead of gzip for better compression. The lzop command must be available in the command path.
     * It is recommended that the archive prefix be set to something like '.lzo.run' for the archive, so that potential
     * users know that they'll need lzop to extract it.
     */
    @Parameter(property = &quot;lzo&quot;)
    private Boolean lzo;

    /**
     * --lz4 : Use lz4 instead of gzip for better compression. The lz4 command must be available in the command path. It
     * is recommended that the archive prefix be set to something like '.lz4.run' for the archive, so that potential
     * users know that they'll need lz4 to extract it.
     */
    @Parameter(property = &quot;lz4&quot;)
    private Boolean lz4;

    /**
     * --zstd : Use zstd for compression.
     */
    @Parameter(property = &quot;zstd&quot;)
    private Boolean zstd;

    /**
     * --pigz : Use pigz for compression.
     */
    @Parameter(property = &quot;pigz&quot;)
    private Boolean pigz;

    /**
     * --base64 : Encode the archive to ASCII in Base64 format (base64 command required).
     */
    @Parameter(property = &quot;base64&quot;)
    private Boolean base64;

    /**
     * --gpg-encrypt : Encrypt the archive using gpg -ac -z $COMPRESS_LEVEL. This will prompt for a password to encrypt
     * with. Assumes that potential users have gpg installed.
     */
    @Parameter(property = &quot;gpgEncrypt&quot;)
    private Boolean gpgEncrypt;

    /**
     * --gpg-asymmetric-encrypt-sign : Instead of compressing, asymmetrically encrypt and sign the data using GPG.&quot;
     */
    @Parameter(property = &quot;gpgAsymmetricEncryptSign&quot;)
    private Boolean gpgAsymmetricEncryptSign;

    /**
     * --ssl-encrypt : Encrypt the archive using openssl aes-256-cbc -a -salt. This will prompt for a password to
     * encrypt with. Assumes that the potential users have the OpenSSL tools installed.
     */
    @Parameter(property = &quot;sslEncrypt&quot;)
    private Boolean sslEncrypt;

    /**
     * --ssl-passwd pass : Use the given password to encrypt the data using OpenSSL.
     */
    @Parameter(property = &quot;sslPasswd&quot;)
    private String sslPasswd;

    /**
     * --ssl-pass-src : Use the given src as the source of password to encrypt the data using OpenSSL. See \&quot;PASS PHRASE
     * ARGUMENTS\&quot; in man openssl. If this option is not supplied, the user wil be asked to enter encryption pasword on
     * the current terminal.
     */
    @Parameter(property = &quot;sslPassSrc&quot;)
    private String sslPassSrc;

    /**
     * --ssl-no-md : Do not use \&quot;-md\&quot; option not supported by older OpenSSL.
     */
    @Parameter(property = &quot;sslNoMd&quot;)
    private Boolean sslNoMd;

    /**
     * --compress : Use the UNIX compress command to compress the data. This should be the default on all platforms that
     * don't have gzip available.
     */
    @Parameter(property = &quot;compress&quot;)
    private Boolean compress;

    /**
     * --complevel : Specify the compression level for gzip, bzip2, bzip3, pbzip2, xz, lzo or lz4. (defaults to 9).
     */
    @Parameter(property = &quot;complevel&quot;)
    private Integer complevel;

    /**
     * --nochown : Do not give the target folder to the current user (default)
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;nochown&quot;)
    private Boolean nochown;

    /**
     * --chown : Give the target folder to the current user recursively
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;chown&quot;)
    private Boolean chown;

    /**
     * --nocomp : Do not use any compression for the archive, which will then be an uncompressed TAR.
     */
    @Parameter(property = &quot;nocomp&quot;)
    private Boolean nocomp;

    /**
     * --threads : Specify the number of threads to be used by compressors that support parallelization. Omit to use
     * compressor's default. Most useful (and required) for opting into xz's threading, usually with --threads=0 for all
     * available cores. pbzip2 and pigz are parallel by default, and setting this value allows limiting the number of
     * threads they use.
     */
    @Parameter(property = &quot;threads&quot;)
    private Integer threads;

    /**
     * --notemp : The generated archive will not extract the files to a temporary directory, but in a new directory
     * created in the current directory. This is better to distribute software packages that may extract and compile by
     * themselves (i.e. launch the compilation through the embedded script).
     */
    @Parameter(property = &quot;notemp&quot;)
    private Boolean notemp;

    /**
     * --needroot : Check that the root user is extracting the archive before proceeding
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;needroot&quot;)
    private Boolean needroot;

    /**
     * --current : Files will be extracted to the current directory, instead of in a subdirectory. This option implies
     * --notemp and ddoes not require aq startup_script.
     */
    @Parameter(property = &quot;current&quot;)
    private Boolean current;

    /**
     * --follow : Follow the symbolic links inside of the archive directory, i.e. store the files that are being pointed
     * to instead of the links themselves.
     */
    @Parameter(property = &quot;follow&quot;)
    private Boolean follow;

    /**
     * --noprogress : Do not show the progress during the decompression
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;noprogress&quot;)
    private Boolean noprogress;

    /**
     * --append (new in 2.1.x): Append data to an existing archive, instead of creating a new one. In this mode, the
     * settings from the original archive are reused (compression type, label, embedded script), and thus don't need to
     * be specified again on the command line.
     */
    @Parameter(property = &quot;append&quot;)
    private Boolean append;

    /**
     * --header: Makeself 2.0 uses a separate file to store the header stub, called makeself-header.sh. By default, it
     * is assumed that it is stored in the same location as makeself.sh. This option can be used to specify its actual
     * location if it is stored someplace else. This is not required for this plugin as the header is provided.
     */
    @Parameter(property = &quot;headerFile&quot;, readonly = true)
    private Boolean headerFile;

    /**
     * .--cleanup: Specify a script that is run when execution is interrupted or finishes successfully. The script is
     * executed with the same environment and initial `script_agrs` as `startup_script`.
     */
    @Parameter(property = &quot;cleanupScript&quot;)
    private String cleanupScript;

    /**
     * --copy : Upon extraction, the archive will first extract itself to a temporary directory. The main application of
     * this is to allow self-contained installers stored in a Makeself archive on a CD, when the installer program will
     * later need to unmount the CD and allow a new one to be inserted. This prevents &quot;Filesystem busy&quot; errors for
     * installers that span multiple CDs.
     */
    @Parameter(property = &quot;copy&quot;)
    private Boolean copy;

    /** --nox11 : Disable the automatic spawning of a new terminal in X11. */
    @Parameter(property = &quot;nox11&quot;)
    private Boolean nox11;

    /** --nox11 : Disable the automatic spawning of a new terminal in X11. */
    @Parameter(property = &quot;nowait&quot;)
    private Boolean nowait;

    /**
     * --nomd5 : Disable the creation of a MD5 checksum for the archive. This speeds up the extraction process if
     * integrity checking is not necessary.
     */
    @Parameter(property = &quot;nomd5&quot;)
    private Boolean nomd5;

    /**
     * --nocrc : Disable the creation of a CRC checksum for the archive. This speeds up the extraction process if
     * integrity checking is not necessary.
     */
    @Parameter(property = &quot;nocrc&quot;)
    private Boolean nocrc;

    /**
     * --sha256 : Compute a SHA256 checksum for the archive.
     */
    @Parameter(property = &quot;sha256&quot;)
    private Boolean sha256;

    /**
     * --sign passphrase : Signature private key to sign the package with.
     *
     * @deprecated use 'signPassphrase'
     */
    @Deprecated
    @Parameter(property = &quot;sign&quot;)
    private String sign;

    /**
     * --sign passphrase : Signature private key to sign the package with.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;signPassphrase&quot;)
    private String signPassphrase;

    /**
     * --lsm file : Provide and LSM file to makeself, that will be embedded in the generated archive. LSM files are
     * describing a software package in a way that is easily parseable. The LSM entry can then be later retrieved using
     * the --lsm argument to the archive. An example of a LSM file is provided with Makeself.
     */
    @Parameter(property = &quot;lsmFile&quot;)
    private String lsmFile;

    /**
     * --gpg-extra opt : Append more options to the gpg command line.
     */
    @Parameter(property = &quot;gpgExtraOpt&quot;)
    private String gpgExtraOpt;

    /**
     * --tar-format opt :Specify the tar archive format (default is ustar); you may use any value accepted by your tar
     * command (such as posix, v7, etc).
     */
    @Parameter(property = &quot;tarFormatOpt&quot;)
    private String tarFormatOpt;

    /**
     * --tar-extra opt : Append more options to the tar command line.
     * &lt;p&gt;
     * For instance, in order to exclude the .git directory from the packaged archive directory using the GNU tar, one
     * can use makeself.sh --tar-extra &quot;--exclude=.git&quot; ...
     */
    @Parameter(property = &quot;tarExtraOpt&quot;)
    private String tarExtraOpt;

    /**
     * --untar-extra opt : Append more options to the during the extraction of the tar archive.
     */
    @Parameter(property = &quot;untarExtraOpt&quot;)
    private String untarExtraOpt;

    /**
     * --target dir : Specify the directory where the archive will be extracted. This option implies --notemp and ddoes
     * not require aq startup_script.
     *
     * @since 1.6.0
     */
    private String extractTargetDir;

    /**
     * --keep-umask : Keep the umask set to shell default, rather than overriding when executing self-extracting
     * archive.
     */
    @Parameter(property = &quot;keepUmask&quot;)
    private Boolean keepUmask;

    /**
     * --export-conf : Export configuration variables to startup_script.
     */
    @Parameter(property = &quot;exportConf&quot;)
    private Boolean exportConf;

    /**
     * --packaging-date date : Use provided string as the packaging date instead of the current date.
     */
    @Parameter(property = &quot;packagingDate&quot;)
    private String packagingDate;

    /**
     * --license : Append a license file.
     */
    @Parameter(property = &quot;licenseFile&quot;)
    private String licenseFile;

    /**
     * --nooverwrite : Do not extract the archive if the specified target directory already exists.
     */
    @Parameter(property = &quot;nooverwrite&quot;)
    private Boolean nooverwrite;

    /**
     * --help-header file : Add a header to the archive's --help output.
     */
    @Parameter(property = &quot;helpHeaderFile&quot;)
    private String helpHeaderFile;

    /** Skip run of plugin. */
    @Parameter(defaultValue = &quot;false&quot;, property = &quot;makeself.skip&quot;)
    private boolean skip;

    /** Auto run : When set to true, resulting shell will be run. This is useful for testing purposes. */
    @Parameter(defaultValue = &quot;false&quot;, property = &quot;autoRun&quot;)
    private boolean autoRun;

    /** The build target. */
    @Parameter(defaultValue = &quot;${project.build.directory}/&quot;, readonly = true)
    private String buildTarget;

    /** The makeself temp directory. */
    @Parameter(defaultValue = &quot;${project.build.directory}/makeself-tmp/&quot;, readonly = true)
    private File makeselfTempDirectory;

    /** Maven ProjectHelper. */
    @Component
    private MavenProjectHelper projectHelper;

    /** Maven Artifact Factory. */
    @Component
    private RepositorySystem repositorySystem;

    /** Maven Project. */
    @Parameter(defaultValue = &quot;${project}&quot;, readonly = true, required = true)
    private MavenProject project;

    /** Maven Local Repository. */
    @Parameter(defaultValue = &quot;${localRepository}&quot;, readonly = true, required = true)
    private ArtifactRepository localRepository;

    /** Maven Remote Artifacts Repositories. */
    @Parameter(property = &quot;project.remoteArtifactRepositories&quot;)
    private List&lt;ArtifactRepository&gt; remoteRepositories;

    /** The makeself. */
    private File makeself;

    /** Static ATTACH_ARTIFACT to maven lifecycle. */
    private static final boolean ATTACH_ARTIFACT = true;

    /** Portable Git. */
    private PortableGit portableGit;

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        // Check if plugin run should be skipped
<span class="nc bnc" id="L593" title="All 2 branches missed.">        if (this.skip) {</span>
<span class="nc" id="L594">            getLog().info(&quot;Makeself is skipped&quot;);</span>
<span class="nc" id="L595">            return;</span>
        }

        // Validate archive directory exists
<span class="nc" id="L599">        File file = new File(buildTarget.concat(archiveDir));</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (!file.exists()) {</span>
<span class="nc" id="L601">            throw new MojoExecutionException(&quot;ArchiveDir: missing '&quot; + buildTarget.concat(archiveDir) + &quot;'&quot;);</span>
        }

        // Validate inline script or startup script file
<span class="nc bnc" id="L605" title="All 2 branches missed.">        if (inlineScript) {</span>
            // Validate inline script has script args
<span class="nc bnc" id="L607" title="All 2 branches missed.">            if (scriptArgs == null) {</span>
<span class="nc" id="L608">                throw new MojoExecutionException(&quot;ScriptArgs required when running inlineScript&quot;);</span>
            }
        } else {
            // Validate startupScript file starts with './'
<span class="nc bnc" id="L612" title="All 2 branches missed.">            if (!startupScript.startsWith(&quot;./&quot;)) {</span>
<span class="nc" id="L613">                throw new MojoExecutionException(&quot;StartupScript required to start with './'&quot;);</span>
            }

            // Validate startupScript file exists
<span class="nc" id="L617">            file = new File(buildTarget.concat(archiveDir).concat(startupScript.substring(1)));</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">            if (!file.exists()) {</span>
<span class="nc" id="L619">                throw new MojoExecutionException(&quot;StartupScript: missing '&quot;</span>
<span class="nc" id="L620">                        + buildTarget.concat(archiveDir).concat(startupScript.substring(1)) + &quot;'&quot;);</span>
            }
        }

        // Setup make self files
<span class="nc" id="L625">        this.extractMakeself();</span>

        // Check git setup
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (MakeselfMojo.WINDOWS) {</span>
<span class="nc" id="L629">            this.checkGitSetup();</span>
        }

        try {
            // Output version of bash
<span class="nc" id="L634">            getLog().debug(&quot;Execute Bash Version&quot;);</span>
<span class="nc" id="L635">            execute(Arrays.asList(gitPath + &quot;bash&quot;, &quot;--version&quot;), !ATTACH_ARTIFACT);</span>

            // Output version of makeself.sh
<span class="nc" id="L638">            getLog().debug(&quot;Execute Makeself Version&quot;);</span>
<span class="nc" id="L639">            execute(Arrays.asList(gitPath + &quot;bash&quot;, makeself.getAbsolutePath(), &quot;--version&quot;), !ATTACH_ARTIFACT);</span>

            // If version arguments supplied, exit as we just printed version.
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (isTrue(version)) {</span>
<span class="nc" id="L643">                return;</span>
            }

            // If help arguments supplied, write output and get out of code.
<span class="nc bnc" id="L647" title="All 2 branches missed.">            if (isTrue(help)) {</span>
<span class="nc" id="L648">                getLog().debug(&quot;Execute Makeself Help&quot;);</span>
<span class="nc" id="L649">                execute(Arrays.asList(gitPath + &quot;bash&quot;, makeself.getAbsolutePath(), &quot;--help&quot;), !ATTACH_ARTIFACT);</span>
<span class="nc" id="L650">                return;</span>
            }

            // Basic Configuration
<span class="nc" id="L654">            getLog().debug(&quot;Loading Makeself Basic Configuration&quot;);</span>
<span class="nc" id="L655">            List&lt;String&gt; target = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L656">            target.addAll(Arrays.asList(gitPath + &quot;bash&quot;, makeself.getAbsolutePath()));</span>
<span class="nc" id="L657">            target.addAll(loadArgs());</span>
<span class="nc" id="L658">            target.add(buildTarget.concat(archiveDir));</span>
<span class="nc" id="L659">            target.add(buildTarget.concat(fileName));</span>
<span class="nc" id="L660">            target.add(label);</span>
<span class="nc" id="L661">            target.add(startupScript);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">            if (scriptArgs != null) {</span>
<span class="nc" id="L663">                target.addAll(scriptArgs);</span>
            }
<span class="nc bnc" id="L665" title="All 2 branches missed.">            if (cleanupScript != null) {</span>
<span class="nc" id="L666">                target.add(cleanupScript);</span>
                // Pass original arguments again
<span class="nc bnc" id="L668" title="All 2 branches missed.">                if (scriptArgs != null) {</span>
<span class="nc" id="L669">                    target.addAll(scriptArgs);</span>
                }
                // Pass cleanup arguments
<span class="nc bnc" id="L672" title="All 2 branches missed.">                if (cleanupArgs != null) {</span>
<span class="nc" id="L673">                    target.addAll(cleanupArgs);</span>
                }
            }

            // Indicate makeself running
<span class="nc" id="L678">            getLog().info(&quot;Running makeself build&quot;);</span>

            // Execute main run of makeself.sh
<span class="nc" id="L681">            getLog().debug(&quot;Execute Makeself Build&quot;);</span>
<span class="nc" id="L682">            execute(target, ATTACH_ARTIFACT);</span>

            // Output info on file makeself created
<span class="nc" id="L685">            getLog().debug(&quot;Execute Makeself Info on Resulting Shell Script&quot;);</span>
<span class="nc" id="L686">            execute(Arrays.asList(gitPath + &quot;bash&quot;, buildTarget.concat(fileName), &quot;--info&quot;), !ATTACH_ARTIFACT);</span>

            // Output list on file makeself created (non windows need)
<span class="nc bnc" id="L689" title="All 2 branches missed.">            if (!MakeselfMojo.WINDOWS) {</span>
<span class="nc" id="L690">                getLog().debug(&quot;Execute Makeself List on Resulting Shell Script&quot;);</span>
<span class="nc" id="L691">                execute(Arrays.asList(gitPath + &quot;bash&quot;, buildTarget.concat(fileName), &quot;--list&quot;), !ATTACH_ARTIFACT);</span>
            }

            // auto run script
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (this.autoRun) {</span>
<span class="nc" id="L696">                getLog().info(&quot;Auto-run created shell (this may take a few minutes)&quot;);</span>
<span class="nc" id="L697">                execute(Arrays.asList(gitPath + &quot;bash&quot;, buildTarget.concat(fileName)), !ATTACH_ARTIFACT);</span>
            }
<span class="nc" id="L699">        } catch (IOException e) {</span>
<span class="nc" id="L700">            getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L701">        } catch (InterruptedException e) {</span>
<span class="nc" id="L702">            getLog().error(&quot;&quot;, e);</span>
            // restore interruption status of the corresponding thread
<span class="nc" id="L704">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L705">        }</span>
<span class="nc" id="L706">    }</span>

    private void execute(List&lt;String&gt; target, boolean attach) throws IOException, InterruptedException {

        // Log execution target
<span class="nc" id="L711">        getLog().debug(&quot;Execution commands: &quot; + target);</span>

        // Create Process Builder
<span class="nc" id="L714">        ProcessBuilder processBuilder = new ProcessBuilder(target);</span>
<span class="nc" id="L715">        processBuilder.redirectErrorStream(true);</span>

        // Add portable git to windows environment
<span class="nc bnc" id="L718" title="All 2 branches missed.">        if (MakeselfMojo.WINDOWS) {</span>
<span class="nc" id="L719">            Map&lt;String, String&gt; envs = processBuilder.environment();</span>
<span class="nc" id="L720">            getLog().debug(&quot;Environment Variables: &quot; + envs);</span>
<span class="nc" id="L721">            final String location = localRepository.getBasedir() + File.separator + this.portableGit.getName()</span>
<span class="nc" id="L722">                    + File.separator + this.portableGit.getVersion();</span>
            // Windows cmd/powershell shows &quot;Path&quot; in this case
<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (envs.get(&quot;Path&quot;) != null) {</span>
<span class="nc" id="L725">                envs.put(&quot;Path&quot;, location + &quot;/usr/bin;&quot; + envs.get(&quot;Path&quot;));</span>
<span class="nc" id="L726">                getLog().debug(&quot;Environment Path Variable: &quot; + envs.get(&quot;Path&quot;));</span>
                // Windows bash shows &quot;PATH&quot; in this case and has issues with spacing as in 'Program Files'
<span class="nc bnc" id="L728" title="All 2 branches missed.">            } else if (envs.get(&quot;PATH&quot;) != null) {</span>
<span class="nc" id="L729">                envs.put(&quot;PATH&quot;,</span>
<span class="nc" id="L730">                        location + &quot;/usr/bin;&quot; + envs.get(&quot;PATH&quot;).replace(&quot;Program Files&quot;, &quot;\&quot;Program Files\&quot;&quot;));</span>
<span class="nc" id="L731">                getLog().debug(&quot;Environment Path Variable: &quot; + envs.get(&quot;PATH&quot;));</span>
            }
        }

        // Create Process
<span class="nc" id="L736">        Process process = processBuilder.start();</span>

        // Write process output
<span class="nc" id="L739">        try (BufferedReader reader = new BufferedReader(</span>
<span class="nc" id="L740">                new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {</span>
<span class="nc" id="L741">            String line = &quot;&quot;;</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">            while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L743">                getLog().info(line);</span>
            }
<span class="nc" id="L745">            getLog().info(&quot;&quot;);</span>
        }

        // Wait for process completion
<span class="nc" id="L749">        int status = process.waitFor();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">        if (status &gt; 0) {</span>
<span class="nc" id="L751">            getLog().error(Joiner.on(&quot; &quot;).join(&quot;makeself failed with error status:&quot;, status));</span>
        }

        // Attach artifact to maven build for install/deploy/release on success
<span class="nc bnc" id="L755" title="All 4 branches missed.">        if (status == 0 &amp;&amp; attach) {</span>
<span class="nc" id="L756">            projectHelper.attachArtifact(project, this.extension, this.classifier,</span>
<span class="nc" id="L757">                    new File(buildTarget, FilenameUtils.getName(fileName)));</span>
        }
<span class="nc" id="L759">    }</span>

    /**
     * Extract makeself.
     */
    private void extractMakeself() {
<span class="nc" id="L765">        getLog().debug(&quot;Extracting Makeself&quot;);</span>

        // Create makeself directory
<span class="nc" id="L768">        File makeselfTemp = new File(makeselfTempDirectory.getAbsolutePath());</span>
<span class="nc bnc" id="L769" title="All 4 branches missed.">        if (!makeselfTemp.exists() &amp;&amp; !makeselfTemp.mkdirs()) {</span>
<span class="nc" id="L770">            getLog().error(Joiner.on(&quot; &quot;).join(&quot;Unable to make directory&quot;, makeselfTempDirectory.getAbsolutePath()));</span>
<span class="nc" id="L771">            return;</span>
        } else {
<span class="nc" id="L773">            getLog().debug(Joiner.on(&quot; &quot;).join(&quot;Created directory for&quot;, makeselfTempDirectory.getAbsolutePath()));</span>
        }

<span class="nc" id="L776">        ClassLoader classloader = this.getClass().getClassLoader();</span>

        // Write makeself script
<span class="nc" id="L779">        makeself = new File(makeselfTempDirectory, &quot;makeself.sh&quot;);</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">        if (!makeself.exists()) {</span>
<span class="nc" id="L781">            getLog().debug(&quot;Writing makeself.sh&quot;);</span>
<span class="nc" id="L782">            try (InputStream link = classloader.getResourceAsStream(&quot;META-INF/makeself/makeself.sh&quot;)) {</span>
<span class="nc" id="L783">                Path path = makeself.getAbsoluteFile().toPath();</span>
<span class="nc" id="L784">                Files.copy(link, path);</span>
<span class="nc" id="L785">                setFilePermissions(makeself);</span>
<span class="nc" id="L786">                setPosixFilePermissions(path);</span>
<span class="nc" id="L787">            } catch (IOException e) {</span>
<span class="nc" id="L788">                getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L789">            }</span>
        }

        // Write makeself-header script
<span class="nc" id="L793">        File makeselfHeader = new File(makeselfTempDirectory, &quot;makeself-header.sh&quot;);</span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">        if (!makeselfHeader.exists()) {</span>
<span class="nc" id="L795">            getLog().debug(&quot;Writing makeself-header.sh&quot;);</span>
<span class="nc" id="L796">            try (InputStream link = classloader.getResourceAsStream(&quot;META-INF/makeself/makeself-header.sh&quot;)) {</span>
<span class="nc" id="L797">                Path path = makeselfHeader.getAbsoluteFile().toPath();</span>
<span class="nc" id="L798">                Files.copy(link, path);</span>
<span class="nc" id="L799">                setFilePermissions(makeselfHeader);</span>
<span class="nc" id="L800">                setPosixFilePermissions(path);</span>
<span class="nc" id="L801">            } catch (IOException e) {</span>
<span class="nc" id="L802">                getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L803">            }</span>
        }
<span class="nc" id="L805">    }</span>

    /**
     * Check Git Setup.
     *
     * @throws MojoFailureException
     *             the mojo failure exception
     */
    private void checkGitSetup() throws MojoFailureException {
        // Get Portable Git Maven Information
<span class="nc" id="L815">        this.portableGit = new PortableGit(getLog());</span>

        // Extract Portable Git
<span class="nc" id="L818">        this.extractPortableGit();</span>
<span class="nc" id="L819">    }</span>

    /**
     * Extract Portable Git.
     */
    private void extractPortableGit() {
<span class="nc" id="L825">        final String location = localRepository.getBasedir() + File.separator + this.portableGit.getName()</span>
<span class="nc" id="L826">                + File.separator + this.portableGit.getVersion();</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">        if (new File(location).exists()) {</span>
<span class="nc" id="L828">            getLog().debug(&quot;Existing 'PortableGit' folder found at &quot; + location);</span>
<span class="nc" id="L829">            gitPath = location + &quot;/usr/bin/&quot;;</span>
<span class="nc" id="L830">            return;</span>
        }

<span class="nc" id="L833">        getLog().info(&quot;Loading portable git&quot;);</span>
<span class="nc" id="L834">        final Artifact artifact = repositorySystem.createArtifactWithClassifier(this.portableGit.getGroupId(),</span>
<span class="nc" id="L835">                this.portableGit.getArtifactId(), this.portableGit.getVersion(), this.portableGit.getType(),</span>
<span class="nc" id="L836">                this.portableGit.getClassifier());</span>

<span class="nc" id="L838">        final ArtifactResolutionRequest artifactResolutionRequest = new ArtifactResolutionRequest();</span>
<span class="nc" id="L839">        artifactResolutionRequest.setArtifact(artifact);</span>
<span class="nc" id="L840">        artifactResolutionRequest.setResolveTransitively(true);</span>
<span class="nc" id="L841">        artifactResolutionRequest.setLocalRepository(localRepository);</span>
<span class="nc" id="L842">        artifactResolutionRequest.setRemoteRepositories(remoteRepositories);</span>
<span class="nc" id="L843">        repositorySystem.resolve(artifactResolutionRequest);</span>

<span class="nc" id="L845">        this.installGit(artifact, location);</span>
<span class="nc" id="L846">    }</span>

    /**
     * Install Git extracts git to .m2/repository under PortableGit.
     *
     * @param artifact
     *            the maven artifact representation for git
     * @param location
     *            the location in maven repository to store portable git
     */
    private void installGit(final Artifact artifact, final String location) {
<span class="nc" id="L857">        File currentFile = null;</span>

        // Unzip 'tar.gz' from repository under 'com/github/hazendaz/git/git-for-windows' into
        // .m2/repository/PortableGit
<span class="nc" id="L861">        try (TarArchiveInputStream tarArchiveInputStream = new TarArchiveInputStream(new GzipCompressorInputStream(</span>
<span class="nc" id="L862">                new BufferedInputStream(Files.newInputStream(artifact.getFile().toPath()))))) {</span>
            TarArchiveEntry entry;
<span class="nc" id="L864">            String directory = localRepository.getBasedir() + File.separator + this.portableGit.getName();</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            while ((entry = tarArchiveInputStream.getNextTarEntry()) != null) {</span>
<span class="nc bnc" id="L866" title="All 2 branches missed.">                if (entry.isDirectory()) {</span>
<span class="nc" id="L867">                    continue;</span>
                }
<span class="nc" id="L869">                currentFile = new File(directory, entry.getName());</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">                if (!currentFile.toPath().normalize().startsWith(directory)) {</span>
<span class="nc" id="L871">                    throw new IOException(&quot;Bad zip entry, possible directory traversal&quot;);</span>
                }
<span class="nc" id="L873">                File parent = currentFile.getParentFile();</span>
<span class="nc bnc" id="L874" title="All 2 branches missed.">                if (!parent.exists()) {</span>
<span class="nc" id="L875">                    parent.mkdirs();</span>
                }
<span class="nc" id="L877">                getLog().debug(&quot;Current file: &quot; + currentFile.getName());</span>
<span class="nc" id="L878">                Files.copy(tarArchiveInputStream, currentFile.toPath(), StandardCopyOption.REPLACE_EXISTING);</span>
<span class="nc" id="L879">            }</span>
<span class="nc" id="L880">        } catch (IOException e) {</span>
<span class="nc" id="L881">            getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L882">        }</span>

        try {
<span class="nc bnc" id="L885" title="All 2 branches missed.">            if (currentFile != null) {</span>
                // Extract Portable Git
<span class="nc" id="L887">                getLog().debug(&quot;Extract Portable Git&quot;);</span>
<span class="nc" id="L888">                execute(Arrays.asList(currentFile.toPath().toString(), &quot;-y&quot;, &quot;-o&quot;, location), !ATTACH_ARTIFACT);</span>
<span class="nc" id="L889">                gitPath = location + &quot;/usr/bin/&quot;;</span>
            }
<span class="nc" id="L891">        } catch (IOException e) {</span>
<span class="nc" id="L892">            getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L893">        } catch (InterruptedException e) {</span>
<span class="nc" id="L894">            getLog().error(&quot;&quot;, e);</span>
            // restore interruption status of the corresponding thread
<span class="nc" id="L896">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L897">        }</span>
<span class="nc" id="L898">    }</span>

    private void setFilePermissions(File file) {
<span class="nc bnc" id="L901" title="All 2 branches missed.">        if (!file.setExecutable(true, true)) {</span>
<span class="nc" id="L902">            getLog().error(Joiner.on(&quot; &quot;).join(&quot;Unable to set executable:&quot;, file.getName()));</span>
        } else {
<span class="nc" id="L904">            getLog().debug(Joiner.on(&quot; &quot;).join(&quot;Set executable for&quot;, file.getName()));</span>
        }
<span class="nc" id="L906">    }</span>

    private void setPosixFilePermissions(Path path) {
<span class="nc" id="L909">        final Set&lt;PosixFilePermission&gt; permissions = PosixFilePermissions.fromString(&quot;rwxr-xr--&quot;);</span>

        try {
<span class="nc" id="L912">            Files.setPosixFilePermissions(path, permissions);</span>
<span class="nc" id="L913">            getLog().debug(Joiner.on(&quot; &quot;).join(&quot;Set Posix File Permissions for&quot;, path, &quot;as&quot;, permissions));</span>
<span class="nc" id="L914">        } catch (IOException e) {</span>
<span class="nc" id="L915">            getLog().error(&quot;Failed attempted Posix permissions&quot;, e);</span>
<span class="nc" id="L916">        } catch (UnsupportedOperationException e) {</span>
            // Attempting but don't care about status if it fails
<span class="nc" id="L918">            getLog().debug(&quot;Failed attempted Posix permissions&quot;, e);</span>
<span class="nc" id="L919">        }</span>
<span class="nc" id="L920">    }</span>

    /**
     * Load args.
     *
     * @return the string
     */
    private List&lt;String&gt; loadArgs() {
<span class="nc" id="L928">        getLog().debug(&quot;Loading arguments&quot;);</span>

<span class="nc" id="L930">        List&lt;String&gt; args = new ArrayList&lt;&gt;(50);</span>

        // &quot; --tar-quietly : Suppress verbose output from the tar command&quot;
<span class="nc bnc" id="L933" title="All 2 branches missed.">        if (isTrue(tarQuietly)) {</span>
<span class="nc" id="L934">            args.add(&quot;--tar-quietly&quot;);</span>
        }

        // &quot; --quiet | -q : Do not print any messages other than errors.&quot;
<span class="nc bnc" id="L938" title="All 2 branches missed.">        if (isTrue(quiet)) {</span>
<span class="nc" id="L939">            args.add(&quot;--quiet&quot;);</span>
        }

        // --gzip : Use gzip for compression (the default on platforms on which gzip is commonly available, like Linux)
<span class="nc bnc" id="L943" title="All 2 branches missed.">        if (isTrue(gzip)) {</span>
<span class="nc" id="L944">            args.add(&quot;--gzip&quot;);</span>
        }

        // --bzip2 : Use bzip2 instead of gzip for better compression. The bzip2 command must be available in the
        // command path. It is recommended that the archive prefix be set to something like '.bz2.run', so that
        // potential users know that they'll need bzip2 to extract it.
<span class="nc bnc" id="L950" title="All 2 branches missed.">        if (isTrue(bzip2)) {</span>
<span class="nc" id="L951">            args.add(&quot;--bzip2&quot;);</span>
        }

        // --bzip3 : Use bzip3 instead of gzip for better compression. The bzip3 command must be available in the
        // command path. It is recommended that the archive prefix be set to something like '.bz3.run', so that
        // potential users know that they'll need bzip3 to extract it.
<span class="nc bnc" id="L957" title="All 2 branches missed.">        if (isTrue(bzip3)) {</span>
<span class="nc" id="L958">            args.add(&quot;--bzip3&quot;);</span>
        }

        // --pbzip2 : Use pbzip2 instead of gzip for better and faster compression on machines having multiple CPUs.
        // The pbzip2 command must be available in the command path. It is recommended that the archive prefix be
        // set to something like '.pbz2.run', so that potential users know that they'll need bzip2 to extract it.
<span class="nc bnc" id="L964" title="All 2 branches missed.">        if (isTrue(pbzip2)) {</span>
<span class="nc" id="L965">            args.add(&quot;--pbzip2&quot;);</span>
        }

        // --xz : Use xz instead of gzip for better compression. The xz command must be available in the command path.
        // It is recommended that the archive prefix be set to something like '.xz.run' for the archive, so that
        // potential users know that they'll need xz to extract it.
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (isTrue(xz)) {</span>
<span class="nc" id="L972">            args.add(&quot;--xz&quot;);</span>
        }

        // --lzo : Use lzop instead of gzip for better compression. The lzop command must be available in the command
        // path. It is recommended that the archive prefix be set to something like '.lzo.run' for the archive, so
        // that potential users know that they'll need lzop to extract it.
<span class="nc bnc" id="L978" title="All 2 branches missed.">        if (isTrue(lzo)) {</span>
<span class="nc" id="L979">            args.add(&quot;--lzo&quot;);</span>
        }

        // --lz4 : Use lz4 instead of gzip for better compression. The lz4 command must be available in the command
        // path. It is recommended that the archive prefix be set to something like '.lz4.run' for the archive, so
        // that potential users know that they'll need lz4 to extract it.
<span class="nc bnc" id="L985" title="All 2 branches missed.">        if (isTrue(lz4)) {</span>
<span class="nc" id="L986">            args.add(&quot;--lz4&quot;);</span>
        }

        // --zstd : Use zstd for compression.
<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (isTrue(zstd)) {</span>
<span class="nc" id="L991">            args.add(&quot;--zstd&quot;);</span>
        }

        // --pigz : Use pigz for compression.
<span class="nc bnc" id="L995" title="All 2 branches missed.">        if (isTrue(pigz)) {</span>
<span class="nc" id="L996">            args.add(&quot;--pigz&quot;);</span>
        }

        // --base64 : Encode the archive to ASCII in Base64 format (base64 command required).
<span class="nc bnc" id="L1000" title="All 2 branches missed.">        if (isTrue(base64)) {</span>
<span class="nc" id="L1001">            args.add(&quot;--base64&quot;);</span>
        }

        // --gpg-encrypt : Encrypt the archive using gpg -ac -z $COMPRESS_LEVEL. This will prompt for a password to
        // encrypt with. Assumes that potential users have gpg installed.
<span class="nc bnc" id="L1006" title="All 2 branches missed.">        if (isTrue(gpgEncrypt)) {</span>
<span class="nc" id="L1007">            args.add(&quot;--gpg-encrypt&quot;);</span>
        }

        // --gpg-asymmetric-encrypt-sign : Instead of compressing, asymmetrically encrypt and sign the data using GPG
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if (isTrue(gpgAsymmetricEncryptSign)) {</span>
<span class="nc" id="L1012">            args.add(&quot;--gpg-asymmetric-encrypt-sign&quot;);</span>
        }

        // --ssl-encrypt : Encrypt the archive using openssl aes-256-cbc -a -salt. This will prompt for a password to
        // encrypt with. Assumes that the potential users have the OpenSSL tools installed.
<span class="nc bnc" id="L1017" title="All 2 branches missed.">        if (isTrue(sslEncrypt)) {</span>
<span class="nc" id="L1018">            args.add(&quot;--ssl-encrypt&quot;);</span>
        }

        // --ssl-passwd pass : Use the given password to encrypt the data using OpenSSL.
<span class="nc bnc" id="L1022" title="All 2 branches missed.">        if (sslPasswd != null) {</span>
<span class="nc" id="L1023">            args.add(&quot;--ssl-passwd&quot;);</span>
<span class="nc" id="L1024">            args.add(sslPasswd);</span>
        }

        // --ssl-pass-src src : Use the given src as the source of password to encrypt the data using OpenSSL. See
        // \&quot;PASS PHRASE ARGUMENTS\&quot; in man openssl. If this option is not supplied, the user wil be asked to enter
        // encryption pasword on the current terminal.
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (sslPassSrc != null) {</span>
<span class="nc" id="L1031">            args.add(&quot;--ssl-pass-src&quot;);</span>
<span class="nc" id="L1032">            args.add(sslPassSrc);</span>
        }

        // --ssl-no-md : Do not use \&quot;-md\&quot; option not supported by older OpenSSL.
<span class="nc bnc" id="L1036" title="All 2 branches missed.">        if (isTrue(sslNoMd)) {</span>
<span class="nc" id="L1037">            args.add(&quot;--ssl-no-md&quot;);</span>
        }

        // --compress : Use the UNIX compress command to compress the data. This should be the default on all platforms
        // that don't have gzip available.
<span class="nc bnc" id="L1042" title="All 2 branches missed.">        if (isTrue(compress)) {</span>
<span class="nc" id="L1043">            args.add(&quot;--compress&quot;);</span>
        }

        // --complevel : Specify the compression level for gzip, bzip2, bzip3, pbzip2, xz, lzo or lz4. (defaults to 9)
<span class="nc bnc" id="L1047" title="All 2 branches missed.">        if (complevel != null) {</span>
<span class="nc" id="L1048">            args.add(&quot;--complevel&quot;);</span>
<span class="nc" id="L1049">            args.add(complevel.toString());</span>
        }

        // --nochown : Do not give the target folder to the current user (default)
<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (isTrue(nochown)) {</span>
<span class="nc" id="L1054">            args.add(&quot;--nochown&quot;);</span>
        }

        // --chown : Give the target folder to the current user recursively.
<span class="nc bnc" id="L1058" title="All 2 branches missed.">        if (isTrue(chown)) {</span>
<span class="nc" id="L1059">            args.add(&quot;--chown&quot;);</span>
        }

        // --nocomp : Do not use any compression for the archive, which will then be an uncompressed TAR.
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (isTrue(nocomp)) {</span>
<span class="nc" id="L1064">            args.add(&quot;--nocomp&quot;);</span>
        }

        // --threads thds : Number of threads to be used by compressors that support parallelization.
        // Omit to use compressor's default. Most useful (and required) for opting into xz's threading,
        // usually with '--threads=0' for all available cores.pbzip2 and pigz are parallel by default,
        // and setting this value allows limiting the number of threads they use.
<span class="nc bnc" id="L1071" title="All 2 branches missed.">        if (threads != null) {</span>
<span class="nc" id="L1072">            args.add(&quot;--threads&quot;);</span>
<span class="nc" id="L1073">            args.add(threads.toString());</span>
        }

        // --notemp : The generated archive will not extract the files to a temporary directory, but in a new directory
        // created in the current directory. This is better to distribute software packages that may extract and compile
        // by themselves (i.e. launch the compilation through the embedded script).
<span class="nc bnc" id="L1079" title="All 2 branches missed.">        if (isTrue(notemp)) {</span>
<span class="nc" id="L1080">            args.add(&quot;--notemp&quot;);</span>
        }

        // --needroot : Check that the root user is extracting the archive before proceeding
<span class="nc bnc" id="L1084" title="All 2 branches missed.">        if (isTrue(needroot)) {</span>
<span class="nc" id="L1085">            args.add(&quot;--needroot&quot;);</span>
        }

        // --current : Files will be extracted to the current directory, instead of in a sub-directory. This option
        // implies
        // --notemp and does not require aq startup_script.
<span class="nc bnc" id="L1091" title="All 2 branches missed.">        if (isTrue(current)) {</span>
<span class="nc" id="L1092">            args.add(&quot;--current&quot;);</span>
        }

        // --follow : Follow the symbolic links inside of the archive directory, i.e. store the files that are being
        // pointed to instead of the links themselves.
<span class="nc bnc" id="L1097" title="All 2 branches missed.">        if (isTrue(follow)) {</span>
<span class="nc" id="L1098">            args.add(&quot;--follow&quot;);</span>
        }

        // --noprogress : Do not show the progress during the decompression
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (isTrue(noprogress)) {</span>
<span class="nc" id="L1103">            args.add(&quot;--noprogress&quot;);</span>
        }

        // --append (new in 2.1.x): Append data to an existing archive, instead of creating a new one. In this mode, the
        // settings from the original archive are reused (compression type, label, embedded script), and thus don't need
        // to be specified again on the command line.
<span class="nc bnc" id="L1109" title="All 2 branches missed.">        if (isTrue(append)) {</span>
<span class="nc" id="L1110">            args.add(&quot;--append&quot;);</span>
        }

        // --header : Makeself 2.0 uses a separate file to store the header stub, called makeself-header.sh. By default,
        // it is assumed that it is stored in the same location as makeself.sh. This option can be used to specify its
        // actual location if it is stored someplace else.
<span class="nc bnc" id="L1116" title="All 2 branches missed.">        if (headerFile != null) {</span>
<span class="nc" id="L1117">            args.add(&quot;--header&quot;);</span>
<span class="nc" id="L1118">            args.add(headerFile.toString());</span>
        }

        // --copy : Upon extraction, the archive will first extract itself to a temporary directory. The main
        // application of this is to allow self-contained installers stored in a Makeself archive on a CD, when the
        // installer program will later need to unmount the CD and allow a new one to be inserted. This prevents
        // &quot;File system busy&quot; errors for installers that span multiple CDs.
<span class="nc bnc" id="L1125" title="All 2 branches missed.">        if (isTrue(copy)) {</span>
<span class="nc" id="L1126">            args.add(&quot;--copy&quot;);</span>
        }

        // --nox11 : Disable the automatic spawning of a new terminal in X11.
<span class="nc bnc" id="L1130" title="All 2 branches missed.">        if (isTrue(nox11)) {</span>
<span class="nc" id="L1131">            args.add(&quot;--nox11&quot;);</span>
        }

        // --nowait : When executed from a new X11 terminal, disable the user prompt at the end of the script execution.
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (isTrue(nowait)) {</span>
<span class="nc" id="L1136">            args.add(&quot;--nowait&quot;);</span>
        }

        // --nomd5 : Disable the creation of a MD5 checksum for the archive. This speeds up the extraction process if
        // integrity checking is not necessary.
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        if (isTrue(nomd5)) {</span>
<span class="nc" id="L1142">            args.add(&quot;--nomd5&quot;);</span>
        }

        // --nocrc : Disable the creation of a CRC checksum for the archive. This speeds up the extraction process if
        // integrity checking is not necessary.
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (isTrue(nocrc)) {</span>
<span class="nc" id="L1148">            args.add(&quot;--nocrc&quot;);</span>
        }

        // --sha256 : Compute a SHA256 checksum for the archive.
<span class="nc bnc" id="L1152" title="All 2 branches missed.">        if (isTrue(sha256)) {</span>
<span class="nc" id="L1153">            args.add(&quot;--sha256&quot;);</span>
        }

        // --lsm file : Provide and LSM file to makeself, that will be embedded in the generated archive. LSM files are
        // describing a software package in a way that is easily parseable. The LSM entry can then be later retrieved
        // using the --lsm argument to the archive. An example of a LSM file is provided
        // with Makeself.
<span class="nc bnc" id="L1160" title="All 2 branches missed.">        if (lsmFile != null) {</span>
<span class="nc" id="L1161">            args.add(&quot;--lsm&quot;);</span>
<span class="nc" id="L1162">            args.add(lsmFile);</span>
        }

        // --gpg-extra opt : Append more options to the gpg command line.
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if (gpgExtraOpt != null) {</span>
<span class="nc" id="L1167">            args.add(&quot;--gpg-extra&quot;);</span>
<span class="nc" id="L1168">            args.add(gpgExtraOpt);</span>
        }

        // --tar-format opt : Specify the tar archive format (default is ustar); you may use any value accepted by your
        // tar command (such as posix, v7, etc).
<span class="nc bnc" id="L1173" title="All 2 branches missed.">        if (tarFormatOpt != null) {</span>
<span class="nc" id="L1174">            args.add(&quot;--tar-format&quot;);</span>
<span class="nc" id="L1175">            args.add(tarFormatOpt);</span>
        }

        // --tar-extra opt : Append more options to the tar command line.
        // For instance, in order to exclude the .git directory from the packaged archive directory using the GNU tar,
        // one can use makeself.sh --tar-extra &quot;--exclude=.git&quot; ...
<span class="nc bnc" id="L1181" title="All 2 branches missed.">        if (tarExtraOpt != null) {</span>
<span class="nc" id="L1182">            args.add(&quot;--tar-extra&quot;);</span>
<span class="nc" id="L1183">            args.add(tarExtraOpt);</span>
        }

        // --untar-extra opt : Append more options to the during the extraction of the tar archive.
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        if (untarExtraOpt != null) {</span>
<span class="nc" id="L1188">            args.add(&quot;--untar-extra&quot;);</span>
<span class="nc" id="L1189">            args.add(untarExtraOpt);</span>
        }

        // --sign passphrase : Signature private key to sign the package with
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (sign != null) {</span>
<span class="nc" id="L1194">            args.add(&quot;--sign&quot;);</span>
<span class="nc" id="L1195">            args.add(sign);</span>
        }

        // --sign passphrase : Signature private key to sign the package with
<span class="nc bnc" id="L1199" title="All 2 branches missed.">        if (signPassphrase != null) {</span>
<span class="nc" id="L1200">            args.add(&quot;--sign&quot;);</span>
<span class="nc" id="L1201">            args.add(signPassphrase);</span>
        }

        // --target dir : Specify the directory where the archive will be extracted. This option implies
        // --notemp and ddoes not require aq startup_script.
<span class="nc bnc" id="L1206" title="All 2 branches missed.">        if (extractTargetDir != null) {</span>
<span class="nc" id="L1207">            args.add(&quot;--target&quot;);</span>
<span class="nc" id="L1208">            args.add(extractTargetDir);</span>
        }

        // --keep-umask : Keep the umask set to shell default, rather than overriding when executing self-extracting
        // archive.
<span class="nc bnc" id="L1213" title="All 2 branches missed.">        if (isTrue(keepUmask)) {</span>
<span class="nc" id="L1214">            args.add(&quot;--keep-umask&quot;);</span>
        }

        // --export-conf : Export configuration variables to startup_script&quot;
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (isTrue(exportConf)) {</span>
<span class="nc" id="L1219">            args.add(&quot;--export-conf&quot;);</span>
        }

        // --packaging-date date : Use provided string as the packaging date instead of the current date.
<span class="nc bnc" id="L1223" title="All 2 branches missed.">        if (packagingDate != null) {</span>
<span class="nc" id="L1224">            args.add(&quot;--packaging-date&quot;);</span>
<span class="nc" id="L1225">            args.add(packagingDate);</span>
        }

        // --license : Append a license file.
<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if (licenseFile != null) {</span>
<span class="nc" id="L1230">            args.add(&quot;--license&quot;);</span>
<span class="nc" id="L1231">            args.add(licenseFile);</span>
        }

        // --nooverwrite : Do not extract the archive if the specified target directory already exists.
<span class="nc bnc" id="L1235" title="All 2 branches missed.">        if (isTrue(nooverwrite)) {</span>
<span class="nc" id="L1236">            args.add(&quot;--nooverwrite&quot;);</span>
        }

        // --help-header file : Add a header to the archive's --help output.
<span class="nc bnc" id="L1240" title="All 2 branches missed.">        if (helpHeaderFile != null) {</span>
<span class="nc" id="L1241">            args.add(&quot;--help-header&quot;);</span>
<span class="nc" id="L1242">            args.add(helpHeaderFile);</span>
        }

<span class="nc" id="L1245">        return args;</span>
    }

    private boolean isTrue(Boolean value) {
<span class="nc bnc" id="L1249" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L1250">            return value.booleanValue();</span>
        }
<span class="nc" id="L1252">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>