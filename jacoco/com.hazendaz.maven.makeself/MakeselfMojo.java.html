<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MakeselfMojo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">makeself-maven-plugin</a> &gt; <a href="index.source.html" class="el_package">com.hazendaz.maven.makeself</a> &gt; <span class="el_source">MakeselfMojo.java</span></div><h1>MakeselfMojo.java</h1><pre class="source lang-java linenums">/*
 *    Copyright 2011-2025 the original author or authors.
 *
 *    This program is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU General Public License
 *    as published by the Free Software Foundation; either version 2
 *    of the License, or (at your option) any later version.
 *
 *    You may obtain a copy of the License at
 *
 *       https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html
 *
 *    This program is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *    GNU General Public License for more details.
 */
package com.hazendaz.maven.makeself;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.nio.file.attribute.PosixFilePermission;
import java.nio.file.attribute.PosixFilePermissions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.inject.Inject;

import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.ArchiveInputStream;
import org.apache.commons.compress.archivers.tar.TarArchiveEntry;
import org.apache.commons.compress.archivers.tar.TarArchiveInputStream;
import org.apache.commons.compress.compressors.gzip.GzipCompressorInputStream;
import org.apache.commons.io.FilenameUtils;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;
import org.apache.maven.project.MavenProjectHelper;
import org.eclipse.aether.RepositorySystem;
import org.eclipse.aether.RepositorySystemSession;
import org.eclipse.aether.artifact.Artifact;
import org.eclipse.aether.artifact.DefaultArtifact;
import org.eclipse.aether.repository.RemoteRepository;
import org.eclipse.aether.resolution.ArtifactRequest;
import org.eclipse.aether.resolution.ArtifactResolutionException;
import org.eclipse.aether.resolution.ArtifactResult;

/**
 * The Class MakeselfMojo.
 */
@Mojo(name = &quot;makeself&quot;, defaultPhase = LifecyclePhase.VERIFY, requiresProject = false)
<span class="nc" id="L67">public class MakeselfMojo extends AbstractMojo {</span>

    /** isWindows is detected at start of plugin to ensure windows needs. */
<span class="nc" id="L70">    private static final boolean WINDOWS = System.getProperty(&quot;os.name&quot;).startsWith(&quot;Windows&quot;);</span>

    /** Permissions for makeself script results. */
    private static final String PERMISSIONS = &quot;rwxr-xr--&quot;;

    /** Static ATTACH_ARTIFACT to maven lifecycle. */
    private static final boolean ATTACH_ARTIFACT = true;

    /** The Constant GIT_USER_BIN. */
    private static final String GIT_USER_BIN = &quot;/usr/bin/&quot;;

    /**
     * The path to existing git install for windows usage. If left blank per default, portable git will be used.
     * Location should be something like 'C:/Program Files/Git'. When set and not windows, it will be treated as blank.
     */
    @Parameter(defaultValue = &quot;&quot;, property = &quot;gitPath&quot;)
    private String gitPath;

    /**
     * archive_dir is the name of the directory that contains the files to be archived.
     */
    @Parameter(defaultValue = &quot;makeself&quot;, property = &quot;archiveDir&quot;, required = true)
    private String archiveDir;

    /**
     * file_name is the name of the archive to be created.
     */
    @Parameter(defaultValue = &quot;makeself.sh&quot;, property = &quot;fileName&quot;, required = true)
    private String fileName;

    /**
     * label is an arbitrary text string describing the package. It will be displayed while extracting the files.
     */
    @Parameter(defaultValue = &quot;Makeself self-extractable archive&quot;, property = &quot;label&quot;, required = true)
    private String label;

    /**
     * startup_script is the command to be executed from within the directory of extracted files. Thus, if you wish to
     * execute a program contained in this directory, you must prefix your command with './'. For example, './program'
     * will be fine.
     */
    @Parameter(defaultValue = &quot;./makeself.sh&quot;, property = &quot;startupScript&quot;, required = true)
    private String startupScript;

    /**
     * extension is for type of fileName being created. It defaults to 'sh' for backwards compatibility. Makeself
     * defines 'run' as its default, therefore when using 'run', set extension to 'run'. This extension is used when
     * attaching resulting artifact to maven.
     *
     * @since 1.5.0
     */
    @Parameter(defaultValue = &quot;sh&quot;, property = &quot;extension&quot;)
    private String extension;

    /**
     * classifier is for fileName being created to allow for more than one. If not defined, multiple artifacts will all
     * be installed to same m2 location. The artifact will take on the project artifact where classfier is the physical
     * name attribute you which to create for the fileName.
     *
     * @since 1.5.0
     */
    @Parameter(property = &quot;classifier&quot;)
    private String classifier;

    /**
     * inline script allows user to skip strict verification of startup script for cases where script is defined
     * directly such as 'echo hello' where 'echo' is a 'program' to run and 'hello' is one of many 'script arguments'.
     * Behaviour of makeself plugin prior to 1.5.0 allowed for this undocumented feature which is further allowed and
     * shown as an example in makeself. Verification therefore checks that both startupScript and scriptArgs exist only.
     *
     * @since 1.5.1
     */
    @Parameter(property = &quot;inlineScript&quot;)
    private boolean inlineScript;

    /**
     * script_args are additional arguments for startup_script passed as an array.
     *
     * &lt;pre&gt;
     * {@code
     * &lt;scriptArgs&gt;
     *   &lt;scriptArg&gt;arg1&lt;/scriptArg&gt;
     *   &lt;scriptArg&gt;arg2&lt;/scriptArg&gt;
     * &lt;/scriptArgs&gt;
     * }
     * &lt;/pre&gt;
     */
    @Parameter(property = &quot;scriptArgs&quot;)
    private List&lt;String&gt; scriptArgs;

    /**
     * --version | -v : Print out Makeself version number and exit
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;version&quot;)
    private Boolean version;

    /**
     * --help | -h : Print out this help message and exit (exit is custom to makeself maven plugin).
     */
    @Parameter(property = &quot;help&quot;)
    private Boolean help;

    /**
     * --tar-quietly : Suppress verbose output from the tar command.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;tarQuietly&quot;)
    private Boolean tarQuietly;

    /**
     * --quiet | -q : Do not print any messages other than errors.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;quiet&quot;)
    private Boolean quiet;

    /**
     * --gzip : Use gzip for compression (the default on platforms on which gzip is commonly available, like Linux).
     */
    @Parameter(property = &quot;gzip&quot;)
    private Boolean gzip;

    /**
     * --bzip2 : Use bzip2 instead of gzip for better compression. The bzip2 command must be available in the command
     * path. It is recommended that the archive prefix be set to something like '.bz2.run', so that potential users know
     * that they'll need bzip2 to extract it.
     */
    @Parameter(property = &quot;bzip2&quot;)
    private Boolean bzip2;

    /**
     * --bzip3 : Use bzip3 instead of gzip for better compression. The bzip3 command must be available in the command
     * path. It is recommended that the archive prefix be set to something like '.bz3.run', so that potential users know
     * that they'll need bzip3 to extract it.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;bzip3&quot;)
    private Boolean bzip3;

    /**
     * --pbzip2 : Use pbzip2 instead of gzip for better and faster compression on machines having multiple CPUs. The
     * pbzip2 command must be available in the command path. It is recommended that the archive prefix be set to
     * something like '.pbz2.run', so that potential users know that they'll need bzip2 to extract it.
     */
    @Parameter(property = &quot;pbzip2&quot;)
    private Boolean pbzip2;

    /**
     * --xz : Use xz instead of gzip for better compression. The xz command must be available in the command path. It is
     * recommended that the archive prefix be set to something like '.xz.run' for the archive, so that potential users
     * know that they'll need xz to extract it.
     */
    @Parameter(property = &quot;xz&quot;)
    private Boolean xz;

    /**
     * --lzo : Use lzop instead of gzip for better compression. The lzop command must be available in the command path.
     * It is recommended that the archive prefix be set to something like '.lzo.run' for the archive, so that potential
     * users know that they'll need lzop to extract it.
     */
    @Parameter(property = &quot;lzo&quot;)
    private Boolean lzo;

    /**
     * --lz4 : Use lz4 instead of gzip for better compression. The lz4 command must be available in the command path. It
     * is recommended that the archive prefix be set to something like '.lz4.run' for the archive, so that potential
     * users know that they'll need lz4 to extract it.
     */
    @Parameter(property = &quot;lz4&quot;)
    private Boolean lz4;

    /**
     * --zstd : Use zstd for compression.
     */
    @Parameter(property = &quot;zstd&quot;)
    private Boolean zstd;

    /**
     * --pigz : Use pigz for compression.
     */
    @Parameter(property = &quot;pigz&quot;)
    private Boolean pigz;

    /**
     * --base64 : Encode the archive to ASCII in Base64 format (base64 command required).
     */
    @Parameter(property = &quot;base64&quot;)
    private Boolean base64;

    /**
     * --gpg-encrypt : Encrypt the archive using gpg -ac -z $COMPRESS_LEVEL. This will prompt for a password to encrypt
     * with. Assumes that potential users have gpg installed.
     */
    @Parameter(property = &quot;gpgEncrypt&quot;)
    private Boolean gpgEncrypt;

    /**
     * --gpg-asymmetric-encrypt-sign : Instead of compressing, asymmetrically encrypt and sign the data using GPG.&quot;
     */
    @Parameter(property = &quot;gpgAsymmetricEncryptSign&quot;)
    private Boolean gpgAsymmetricEncryptSign;

    /**
     * --ssl-encrypt : Encrypt the archive using openssl aes-256-cbc -a -salt. This will prompt for a password to
     * encrypt with. Assumes that the potential users have the OpenSSL tools installed.
     */
    @Parameter(property = &quot;sslEncrypt&quot;)
    private Boolean sslEncrypt;

    /**
     * --ssl-passwd pass : Use the given password to encrypt the data using OpenSSL.
     */
    @Parameter(property = &quot;sslPasswd&quot;)
    private String sslPasswd;

    /**
     * --ssl-pass-src : Use the given src as the source of password to encrypt the data using OpenSSL. See \&quot;PASS PHRASE
     * ARGUMENTS\&quot; in man openssl. If this option is not supplied, the user wil be asked to enter encryption pasword on
     * the current terminal.
     */
    @Parameter(property = &quot;sslPassSrc&quot;)
    private String sslPassSrc;

    /**
     * --ssl-no-md : Do not use \&quot;-md\&quot; option not supported by older OpenSSL.
     */
    @Parameter(property = &quot;sslNoMd&quot;)
    private Boolean sslNoMd;

    /**
     * --compress : Use the UNIX compress command to compress the data. This should be the default on all platforms that
     * don't have gzip available.
     */
    @Parameter(property = &quot;compress&quot;)
    private Boolean compress;

    /**
     * --complevel : Specify the compression level for gzip, bzip2, bzip3, pbzip2, xz, lzo or lz4. (defaults to 9).
     */
    @Parameter(property = &quot;complevel&quot;)
    private Integer complevel;

    /**
     * --comp-extra : Append extra options to the chosen compressor.
     */
    @Parameter(property = &quot;compExtra&quot;)
    private String compExtra;

    /**
     * --nochown : Do not give the target folder to the current user (default)
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;nochown&quot;)
    private Boolean nochown;

    /**
     * --chown : Give the target folder to the current user recursively
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;chown&quot;)
    private Boolean chown;

    /**
     * --nocomp : Do not use any compression for the archive, which will then be an uncompressed TAR.
     */
    @Parameter(property = &quot;nocomp&quot;)
    private Boolean nocomp;

    /**
     * --threads : Specify the number of threads to be used by compressors that support parallelization. Omit to use
     * compressor's default. Most useful (and required) for opting into xz's threading, usually with --threads=0 for all
     * available cores. pbzip2 and pigz are parallel by default, and setting this value allows limiting the number of
     * threads they use.
     */
    @Parameter(property = &quot;threads&quot;)
    private Integer threads;

    /**
     * --notemp : The generated archive will not extract the files to a temporary directory, but in a new directory
     * created in the current directory. This is better to distribute software packages that may extract and compile by
     * themselves (i.e. launch the compilation through the embedded script).
     */
    @Parameter(property = &quot;notemp&quot;)
    private Boolean notemp;

    /**
     * --needroot : Check that the root user is extracting the archive before proceeding
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;needroot&quot;)
    private Boolean needroot;

    /**
     * --current : Files will be extracted to the current directory, instead of in a subdirectory. This option implies
     * --notemp and ddoes not require aq startup_script.
     */
    @Parameter(property = &quot;current&quot;)
    private Boolean current;

    /**
     * --follow : Follow the symbolic links inside of the archive directory, i.e. store the files that are being pointed
     * to instead of the links themselves.
     */
    @Parameter(property = &quot;follow&quot;)
    private Boolean follow;

    /**
     * --noprogress : Do not show the progress during the decompression
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;noprogress&quot;)
    private Boolean noprogress;

    /**
     * --append (new in 2.1.x): Append data to an existing archive, instead of creating a new one. In this mode, the
     * settings from the original archive are reused (compression type, label, embedded script), and thus don't need to
     * be specified again on the command line.
     */
    @Parameter(property = &quot;append&quot;)
    private Boolean append;

    /**
     * --header: Makeself 2.0 uses a separate file to store the header stub, called makeself-header.sh. By default, it
     * is assumed that it is stored in the same location as makeself.sh. This option can be used to specify its actual
     * location if it is stored someplace else. This is not required for this plugin as the header is provided.
     */
    @Parameter(property = &quot;headerFile&quot;)
    private String headerFile;

    /**
     * --preextract: Specify a pre-extraction script. The script is executed with the same environment and initial
     * `script_args` as `startup_script`.
     *
     * @since 1.7.0
     */
    @Parameter(property = &quot;preextractScript&quot;)
    private String preextractScript;

    /**
     * --cleanup: Specify a script that is run when execution is interrupted or finishes successfully. The script is
     * executed with the same environment and initial `script_args` as `startup_script`.
     */
    @Parameter(property = &quot;cleanupScript&quot;)
    private String cleanupScript;

    /**
     * --copy : Upon extraction, the archive will first extract itself to a temporary directory. The main application of
     * this is to allow self-contained installers stored in a Makeself archive on a CD, when the installer program will
     * later need to unmount the CD and allow a new one to be inserted. This prevents &quot;Filesystem busy&quot; errors for
     * installers that span multiple CDs.
     */
    @Parameter(property = &quot;copy&quot;)
    private Boolean copy;

    /** --nox11 : Disable the automatic spawning of a new terminal in X11. */
    @Parameter(property = &quot;nox11&quot;)
    private Boolean nox11;

    /** --nowait : Do not wait for user input after executing embedded program from an xterm. */
    @Parameter(property = &quot;nowait&quot;)
    private Boolean nowait;

    /**
     * --nomd5 : Disable the creation of a MD5 checksum for the archive. This speeds up the extraction process if
     * integrity checking is not necessary.
     */
    @Parameter(property = &quot;nomd5&quot;)
    private Boolean nomd5;

    /**
     * --nocrc : Disable the creation of a CRC checksum for the archive. This speeds up the extraction process if
     * integrity checking is not necessary.
     */
    @Parameter(property = &quot;nocrc&quot;)
    private Boolean nocrc;

    /**
     * --sha256 : Compute a SHA256 checksum for the archive.
     */
    @Parameter(property = &quot;sha256&quot;)
    private Boolean sha256;

    /**
     * --sign passphrase : Signature private key to sign the package with.
     *
     * @since 1.6.0
     */
    @Parameter(property = &quot;signPassphrase&quot;)
    private String signPassphrase;

    /**
     * --lsm file : Provide and LSM file to makeself, that will be embedded in the generated archive. LSM files are
     * describing a software package in a way that is easily parseable. The LSM entry can then be later retrieved using
     * the --lsm argument to the archive. An example of a LSM file is provided with Makeself.
     */
    @Parameter(property = &quot;lsmFile&quot;)
    private String lsmFile;

    /**
     * --gpg-extra opt : Append more options to the gpg command line.
     */
    @Parameter(property = &quot;gpgExtraOpt&quot;)
    private String gpgExtraOpt;

    /**
     * --tar-format opt :Specify the tar archive format (default is ustar); you may use any value accepted by your tar
     * command (such as posix, v7, etc).
     */
    @Parameter(property = &quot;tarFormatOpt&quot;)
    private String tarFormatOpt;

    /**
     * --tar-extra opt : Append more options to the tar command line.
     * &lt;p&gt;
     * For instance, in order to exclude the .git directory from the packaged archive directory using the GNU tar, one
     * can use makeself.sh --tar-extra &quot;--exclude=.git&quot; ...
     */
    @Parameter(property = &quot;tarExtraOpt&quot;)
    private String tarExtraOpt;

    /**
     * --untar-extra opt : Append more options to the during the extraction of the tar archive.
     */
    @Parameter(property = &quot;untarExtraOpt&quot;)
    private String untarExtraOpt;

    /**
     * --target dir : Specify the directory where the archive will be extracted. This option implies --notemp and does
     * not require a startup_script.
     *
     * @since 1.6.0
     */
    private String extractTargetDir;

    /**
     * --keep-umask : Keep the umask set to shell default, rather than overriding when executing self-extracting
     * archive.
     */
    @Parameter(property = &quot;keepUmask&quot;)
    private Boolean keepUmask;

    /**
     * --export-conf : Export configuration variables to startup_script.
     */
    @Parameter(property = &quot;exportConf&quot;)
    private Boolean exportConf;

    /**
     * --packaging-date date : Use provided string as the packaging date instead of the current date.
     */
    @Parameter(property = &quot;packagingDate&quot;)
    private String packagingDate;

    /**
     * --license : Append a license file.
     */
    @Parameter(property = &quot;licenseFile&quot;)
    private String licenseFile;

    /**
     * --nooverwrite : Do not extract the archive if the specified target directory already exists.
     */
    @Parameter(property = &quot;nooverwrite&quot;)
    private Boolean nooverwrite;

    /**
     * --help-header file : Add a header to the archive's --help output.
     */
    @Parameter(property = &quot;helpHeaderFile&quot;)
    private String helpHeaderFile;

    /** Skip run of plugin. */
    @Parameter(defaultValue = &quot;false&quot;, property = &quot;makeself.skip&quot;)
    private boolean skip;

    /** Auto run : When set to true, resulting shell will be run. This is useful for testing purposes. */
    @Parameter(defaultValue = &quot;false&quot;, property = &quot;autoRun&quot;)
    private boolean autoRun;

    /** The build target. */
    @Parameter(defaultValue = &quot;${project.build.directory}/&quot;, readonly = true)
    private String buildTarget;

    /** The makeself temp directory. */
    @Parameter(defaultValue = &quot;${project.build.directory}/makeself-tmp/&quot;, readonly = true)
    private File makeselfTempDirectory;

    /** Maven ProjectHelper. */
    @Inject
    private MavenProjectHelper projectHelper;

    /** Maven Artifact Factory. */
    @Inject
    private RepositorySystem repositorySystem;

    /** Maven Project. */
    @Parameter(defaultValue = &quot;${project}&quot;, readonly = true, required = true)
    private MavenProject project;

    /** Maven Repository System Session. */
    @Parameter(defaultValue = &quot;${repositorySystemSession}&quot;, readonly = true, required = true)
    private RepositorySystemSession repoSession;

    /** Maven Remote Repositories. */
    @Parameter(defaultValue = &quot;${project.remoteProjectRepositories}&quot;, readonly = true, required = true)
    protected List&lt;RemoteRepository&gt; remoteRepositories;

    /** The makeself. */
    private Path makeself;

    /** Portable Git. */
    private PortableGit portableGit;

    @Override
    public void execute() throws MojoExecutionException, MojoFailureException {
        // Ensure gitPath is never null
<span class="nc bnc" id="L595" title="All 2 branches missed.">        if (gitPath == null) {</span>
<span class="nc" id="L596">            gitPath = &quot;&quot;;</span>
        }

        // Check if plugin run should be skipped
<span class="nc bnc" id="L600" title="All 2 branches missed.">        if (this.skip) {</span>
<span class="nc" id="L601">            getLog().info(&quot;Makeself is skipped&quot;);</span>
<span class="nc" id="L602">            return;</span>
        }

        // Validate archive directory exists
<span class="nc" id="L606">        Path path = Path.of(buildTarget.concat(archiveDir));</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">        if (!Files.exists(path)) {</span>
<span class="nc" id="L608">            throw new MojoExecutionException(&quot;ArchiveDir: missing '&quot; + buildTarget.concat(archiveDir) + &quot;'&quot;);</span>
        }

        // Validate inline script or startup script file
<span class="nc bnc" id="L612" title="All 2 branches missed.">        if (inlineScript) {</span>
            // Validate inline script has script args
<span class="nc bnc" id="L614" title="All 2 branches missed.">            if (scriptArgs == null) {</span>
<span class="nc" id="L615">                throw new MojoExecutionException(&quot;ScriptArgs required when running inlineScript&quot;);</span>
            }
        } else {
            // Validate startupScript file starts with './'
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (!startupScript.startsWith(&quot;./&quot;)) {</span>
<span class="nc" id="L620">                throw new MojoExecutionException(&quot;StartupScript required to start with './'&quot;);</span>
            }

            // Validate startupScript file exists
<span class="nc" id="L624">            path = Path.of(buildTarget.concat(archiveDir).concat(startupScript.substring(1)));</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">            if (!Files.exists(path)) {</span>
<span class="nc" id="L626">                throw new MojoExecutionException(&quot;StartupScript: missing '&quot;</span>
<span class="nc" id="L627">                        + buildTarget.concat(archiveDir).concat(startupScript.substring(1)) + &quot;'&quot;);</span>
            }
        }

        // Setup make self files
<span class="nc" id="L632">        this.extractMakeself();</span>

        // Check git setup
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (MakeselfMojo.WINDOWS) {</span>
<span class="nc bnc" id="L636" title="All 4 branches missed.">            if (!gitPath.isEmpty() &amp;&amp; Files.exists(Path.of(gitPath))) {</span>
<span class="nc" id="L637">                getLog().debug(&quot;Using existing 'Git' found at &quot; + gitPath);</span>
<span class="nc" id="L638">                gitPath = gitPath + GIT_USER_BIN;</span>
            } else {
<span class="nc" id="L640">                this.checkGitSetup();</span>
            }
        } else {
            // Do not use git path when not windows
<span class="nc" id="L644">            gitPath = &quot;&quot;;</span>
        }

        try {
            // Output version of bash
<span class="nc" id="L649">            getLog().debug(&quot;Execute Bash Version&quot;);</span>
<span class="nc" id="L650">            execute(Arrays.asList(gitPath + &quot;bash&quot;, &quot;--version&quot;), !ATTACH_ARTIFACT);</span>

            // Output version of makeself.sh
<span class="nc" id="L653">            getLog().debug(&quot;Execute Makeself Version&quot;);</span>
<span class="nc" id="L654">            execute(Arrays.asList(gitPath + &quot;bash&quot;, makeself.toAbsolutePath().toString(), &quot;--version&quot;),</span>
                    !ATTACH_ARTIFACT);

            // If version arguments supplied, exit as we just printed version.
<span class="nc bnc" id="L658" title="All 2 branches missed.">            if (isTrue(version)) {</span>
<span class="nc" id="L659">                return;</span>
            }

            // If help arguments supplied, write output and get out of code.
<span class="nc bnc" id="L663" title="All 2 branches missed.">            if (isTrue(help)) {</span>
<span class="nc" id="L664">                getLog().debug(&quot;Execute Makeself Help&quot;);</span>
<span class="nc" id="L665">                execute(Arrays.asList(gitPath + &quot;bash&quot;, makeself.toAbsolutePath().toString(), &quot;--help&quot;),</span>
                        !ATTACH_ARTIFACT);
<span class="nc" id="L667">                return;</span>
            }

            // Basic Configuration
<span class="nc" id="L671">            getLog().debug(&quot;Loading Makeself Basic Configuration&quot;);</span>
<span class="nc" id="L672">            List&lt;String&gt; target = new ArrayList&lt;&gt;(</span>
<span class="nc" id="L673">                    Arrays.asList(gitPath + &quot;bash&quot;, makeself.toAbsolutePath().toString()));</span>
<span class="nc" id="L674">            target.addAll(loadArgs());</span>
<span class="nc" id="L675">            target.add(buildTarget.concat(archiveDir));</span>
<span class="nc" id="L676">            target.add(buildTarget.concat(fileName));</span>
<span class="nc" id="L677">            target.add(label);</span>
<span class="nc" id="L678">            target.add(startupScript);</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">            if (scriptArgs != null) {</span>
<span class="nc" id="L680">                target.addAll(scriptArgs);</span>
            }

            // Indicate makeself running
<span class="nc" id="L684">            getLog().info(&quot;Running makeself build&quot;);</span>

            // Execute main run of makeself.sh
<span class="nc" id="L687">            getLog().debug(&quot;Execute Makeself Build&quot;);</span>
<span class="nc" id="L688">            execute(target, ATTACH_ARTIFACT);</span>

            // Output info on file makeself created
<span class="nc" id="L691">            getLog().debug(&quot;Execute Makeself Info on Resulting Shell Script&quot;);</span>
<span class="nc" id="L692">            execute(Arrays.asList(gitPath + &quot;bash&quot;, buildTarget.concat(fileName), &quot;--info&quot;), !ATTACH_ARTIFACT);</span>

            // Output list on file makeself created (non windows need)
<span class="nc bnc" id="L695" title="All 2 branches missed.">            if (!MakeselfMojo.WINDOWS) {</span>
<span class="nc" id="L696">                getLog().debug(&quot;Execute Makeself List on Resulting Shell Script&quot;);</span>
<span class="nc" id="L697">                execute(Arrays.asList(gitPath + &quot;bash&quot;, buildTarget.concat(fileName), &quot;--list&quot;), !ATTACH_ARTIFACT);</span>
            }

            // auto run script
<span class="nc bnc" id="L701" title="All 2 branches missed.">            if (this.autoRun) {</span>
<span class="nc" id="L702">                getLog().info(&quot;Auto-run created shell (this may take a few minutes)&quot;);</span>
<span class="nc" id="L703">                execute(Arrays.asList(gitPath + &quot;bash&quot;, buildTarget.concat(fileName)), !ATTACH_ARTIFACT);</span>
            }
<span class="nc" id="L705">        } catch (IOException e) {</span>
<span class="nc" id="L706">            getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L707">        } catch (InterruptedException e) {</span>
<span class="nc" id="L708">            getLog().error(&quot;&quot;, e);</span>
            // restore interruption status of the corresponding thread
<span class="nc" id="L710">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L711">        }</span>
<span class="nc" id="L712">    }</span>

    private void execute(List&lt;String&gt; target, boolean attach) throws IOException, InterruptedException {

        // Log execution target
<span class="nc" id="L717">        getLog().debug(&quot;Execution commands: &quot; + target);</span>

        // Create Process Builder
<span class="nc" id="L720">        ProcessBuilder processBuilder = new ProcessBuilder(target);</span>
<span class="nc" id="L721">        processBuilder.redirectErrorStream(true);</span>

        // Add portable git to windows environment
<span class="nc bnc" id="L724" title="All 2 branches missed.">        if (MakeselfMojo.WINDOWS) {</span>
<span class="nc" id="L725">            Map&lt;String, String&gt; envs = processBuilder.environment();</span>
<span class="nc" id="L726">            getLog().debug(&quot;Environment Variables: &quot; + envs);</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">            if (this.portableGit == null) {</span>
                // Helper as git located in provided location (not real user or system path, just the process)
<span class="nc" id="L730">                final String location = gitPath;</span>
                // Windows cmd/powershell shows &quot;Path&quot; in this case
<span class="nc bnc" id="L732" title="All 2 branches missed.">                if (envs.get(&quot;Path&quot;) != null) {</span>
<span class="nc" id="L733">                    envs.put(&quot;Path&quot;, location + &quot;;&quot; + envs.get(&quot;Path&quot;));</span>
<span class="nc" id="L734">                    getLog().debug(&quot;Environment Path Variable: &quot; + envs.get(&quot;Path&quot;));</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">                } else if (envs.get(&quot;PATH&quot;) != null) {</span>
                    // Windows bash shows &quot;PATH&quot; in this case and has issues with spacing as in 'Program Files'
<span class="nc" id="L737">                    envs.put(&quot;PATH&quot;, location + &quot;;&quot; + envs.get(&quot;PATH&quot;).replace(&quot;Program Files&quot;, &quot;\&quot;Program Files\&quot;&quot;));</span>
<span class="nc" id="L738">                    getLog().debug(&quot;Environment Path Variable: &quot; + envs.get(&quot;PATH&quot;));</span>
                }
<span class="nc" id="L740">            } else {</span>
                // Helper as portable git located in .m2 (not real user or system path, just the process)
<span class="nc" id="L742">                final String location = repoSession.getLocalRepository().getBasedir() + File.separator</span>
<span class="nc" id="L743">                        + this.portableGit.getName() + File.separator + this.portableGit.getVersion();</span>
                // Windows cmd/powershell shows &quot;Path&quot; in this case
<span class="nc bnc" id="L745" title="All 2 branches missed.">                if (envs.get(&quot;Path&quot;) != null) {</span>
<span class="nc" id="L746">                    envs.put(&quot;Path&quot;, location + &quot;/usr/bin;&quot; + envs.get(&quot;Path&quot;));</span>
<span class="nc" id="L747">                    getLog().debug(&quot;Environment Path Variable: &quot; + envs.get(&quot;Path&quot;));</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">                } else if (envs.get(&quot;PATH&quot;) != null) {</span>
                    // Windows bash shows &quot;PATH&quot; in this case and has issues with spacing as in 'Program Files'
<span class="nc" id="L750">                    envs.put(&quot;PATH&quot;,</span>
<span class="nc" id="L751">                            location + &quot;/usr/bin;&quot; + envs.get(&quot;PATH&quot;).replace(&quot;Program Files&quot;, &quot;\&quot;Program Files\&quot;&quot;));</span>
<span class="nc" id="L752">                    getLog().debug(&quot;Environment Path Variable: &quot; + envs.get(&quot;PATH&quot;));</span>
                }
            }
        }

        // Create Process
<span class="nc" id="L758">        Process process = processBuilder.start();</span>

        // Write process output
<span class="nc" id="L761">        try (BufferedReader reader = new BufferedReader(</span>
<span class="nc" id="L762">                new InputStreamReader(process.getInputStream(), StandardCharsets.UTF_8))) {</span>
<span class="nc" id="L763">            String line = &quot;&quot;;</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">            while ((line = reader.readLine()) != null) {</span>
<span class="nc" id="L765">                getLog().info(line);</span>
            }
<span class="nc" id="L767">            getLog().info(&quot;&quot;);</span>
        }

        // Wait for process completion
<span class="nc" id="L771">        int status = process.waitFor();</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">        if (status &gt; 0) {</span>
<span class="nc" id="L773">            getLog().error(String.join(&quot; &quot;, &quot;makeself failed with error status:&quot;, String.valueOf(status)));</span>
        }

        // Attach artifact to maven build for install/deploy/release on success
<span class="nc bnc" id="L777" title="All 4 branches missed.">        if (status == 0 &amp;&amp; attach) {</span>
<span class="nc" id="L778">            projectHelper.attachArtifact(project, this.extension, this.classifier,</span>
<span class="nc" id="L779">                    Path.of(buildTarget, FilenameUtils.getName(fileName)).toFile());</span>
        }
<span class="nc" id="L781">    }</span>

    /**
     * Extract makeself.
     */
    private void extractMakeself() {
<span class="nc" id="L787">        getLog().debug(&quot;Extracting Makeself&quot;);</span>

        // Create makeself directory
<span class="nc" id="L790">        Path makeselfTemp = Path.of(makeselfTempDirectory.getAbsolutePath());</span>
<span class="nc bnc" id="L791" title="All 4 branches missed.">        if (!Files.exists(makeselfTemp) &amp;&amp; !makeselfTemp.toFile().mkdirs()) {</span>
<span class="nc" id="L792">            getLog().error(String.join(&quot; &quot;, &quot;Unable to make directory&quot;, makeselfTempDirectory.getAbsolutePath()));</span>
<span class="nc" id="L793">            return;</span>
        }
<span class="nc" id="L795">        getLog().debug(String.join(&quot; &quot;, &quot;Created directory for&quot;, makeselfTempDirectory.getAbsolutePath()));</span>

<span class="nc" id="L797">        ClassLoader classloader = this.getClass().getClassLoader();</span>

        // Write makeself script
<span class="nc" id="L800">        makeself = makeselfTempDirectory.toPath().resolve(&quot;makeself.sh&quot;);</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">        if (!Files.exists(makeself)) {</span>
<span class="nc" id="L802">            getLog().debug(&quot;Writing makeself.sh&quot;);</span>
<span class="nc" id="L803">            try (InputStream link = classloader.getResourceAsStream(&quot;META-INF/makeself/makeself.sh&quot;)) {</span>
<span class="nc" id="L804">                Path path = makeself.toAbsolutePath();</span>
<span class="nc" id="L805">                Files.copy(link, path);</span>
<span class="nc" id="L806">                setFilePermissions(makeself.toFile());</span>
<span class="nc" id="L807">                setPosixFilePermissions(path);</span>
<span class="nc" id="L808">            } catch (IOException e) {</span>
<span class="nc" id="L809">                getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L810">            }</span>
        }

        // Write makeself-header script
<span class="nc" id="L814">        Path makeselfHeader = makeselfTempDirectory.toPath().resolve(&quot;makeself-header.sh&quot;);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">        if (!Files.exists(makeselfHeader)) {</span>
<span class="nc" id="L816">            getLog().debug(&quot;Writing makeself-header.sh&quot;);</span>
<span class="nc" id="L817">            try (InputStream link = classloader.getResourceAsStream(&quot;META-INF/makeself/makeself-header.sh&quot;)) {</span>
<span class="nc" id="L818">                Path path = makeselfHeader.toAbsolutePath();</span>
<span class="nc" id="L819">                Files.copy(link, path);</span>
<span class="nc" id="L820">                setFilePermissions(makeselfHeader.toFile());</span>
<span class="nc" id="L821">                setPosixFilePermissions(path);</span>
<span class="nc" id="L822">            } catch (IOException e) {</span>
<span class="nc" id="L823">                getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L824">            }</span>
        }
<span class="nc" id="L826">    }</span>

    /**
     * Check Git Setup.
     *
     * @throws MojoFailureException
     *             the mojo failure exception
     */
    private void checkGitSetup() throws MojoFailureException {
        // Get Portable Git Maven Information
<span class="nc" id="L836">        this.portableGit = new PortableGit(getLog());</span>

        // Extract Portable Git
<span class="nc" id="L839">        this.extractPortableGit();</span>
<span class="nc" id="L840">    }</span>

    /**
     * Extract Portable Git.
     *
     * @throws MojoFailureException
     *             failure retrieving portable git
     */
    private void extractPortableGit() throws MojoFailureException {
<span class="nc" id="L849">        final String location = repoSession.getLocalRepository().getBasedir() + File.separator</span>
<span class="nc" id="L850">                + this.portableGit.getName() + File.separator + this.portableGit.getVersion();</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (Files.exists(Path.of(location))) {</span>
<span class="nc" id="L852">            getLog().debug(&quot;Existing 'PortableGit' folder found at &quot; + location);</span>
<span class="nc" id="L853">            gitPath = location + GIT_USER_BIN;</span>
<span class="nc" id="L854">            return;</span>
        }

<span class="nc" id="L857">        getLog().info(&quot;Loading portable git&quot;);</span>
<span class="nc" id="L858">        final Artifact artifact = new DefaultArtifact(this.portableGit.getGroupId(), this.portableGit.getArtifactId(),</span>
<span class="nc" id="L859">                this.portableGit.getClassifier(), this.portableGit.getExtension(), this.portableGit.getVersion());</span>
<span class="nc" id="L860">        final ArtifactRequest artifactRequest = new ArtifactRequest().setRepositories(this.remoteRepositories)</span>
<span class="nc" id="L861">                .setArtifact(artifact);</span>
<span class="nc" id="L862">        ArtifactResult resolutionResult = null;</span>
        try {
<span class="nc" id="L864">            resolutionResult = repositorySystem.resolveArtifact(repoSession, artifactRequest);</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">            if (!resolutionResult.isResolved()) {</span>
<span class="nc" id="L866">                throw new MojoFailureException(&quot;Unable to resolve artifact: &quot; + artifact.getGroupId() + &quot;:&quot;</span>
<span class="nc" id="L867">                        + artifact.getArtifactId() + &quot;:&quot; + artifact.getVersion() + &quot;:&quot; + artifact.getClassifier() + &quot;:&quot;</span>
<span class="nc" id="L868">                        + artifact.getExtension());</span>
            }
<span class="nc" id="L870">        } catch (ArtifactResolutionException e) {</span>
<span class="nc" id="L871">            throw new MojoFailureException(</span>
<span class="nc" id="L872">                    &quot;Unable to resolve artifact: &quot; + artifact.getGroupId() + &quot;:&quot; + artifact.getArtifactId() + &quot;:&quot;</span>
<span class="nc" id="L873">                            + artifact.getVersion() + &quot;:&quot; + artifact.getClassifier() + &quot;:&quot; + artifact.getExtension());</span>
<span class="nc" id="L874">        }</span>
<span class="nc" id="L875">        this.installGit(resolutionResult.getArtifact(), location);</span>
<span class="nc" id="L876">    }</span>

    /**
     * Install Git extracts git to .m2/repository under PortableGit.
     *
     * @param artifact
     *            the maven artifact representation for git
     * @param location
     *            the location in maven repository to store portable git
     */
    private void installGit(final Artifact artifact, final String location) {
<span class="nc" id="L887">        Path currentFile = null;</span>

        // Unzip 'git-for-windows-*-portable.tar.gz' from '.m2/repository/com/github/hazendaz/git/git-for-windows'
        // into '.m2/repository/PortableGit'
<span class="nc" id="L891">        try (InputStream inputStream = Files.newInputStream(artifact.getFile().toPath());</span>
<span class="nc" id="L892">                InputStream bufferedStream = new BufferedInputStream(inputStream);</span>
<span class="nc" id="L893">                InputStream gzipStream = new GzipCompressorInputStream(bufferedStream);</span>
<span class="nc" id="L894">                ArchiveInputStream&lt;TarArchiveEntry&gt; tarStream = new TarArchiveInputStream(gzipStream)) {</span>
            ArchiveEntry entry;
<span class="nc" id="L896">            String directory = repoSession.getLocalRepository().getBasedir() + File.separator</span>
<span class="nc" id="L897">                    + this.portableGit.getName();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">            while ((entry = tarStream.getNextEntry()) != null) {</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">                if (entry.isDirectory()) {</span>
<span class="nc" id="L900">                    continue;</span>
                }
<span class="nc" id="L902">                currentFile = Path.of(directory, entry.getName());</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">                if (!currentFile.normalize().startsWith(directory)) {</span>
<span class="nc" id="L904">                    throw new IOException(&quot;Bad zip entry, possible directory traversal&quot;);</span>
                }
<span class="nc" id="L906">                Path parent = currentFile.getParent();</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">                if (!Files.exists(parent)) {</span>
<span class="nc" id="L908">                    Files.createDirectory(parent);</span>
                }
<span class="nc" id="L910">                getLog().debug(&quot;Current file: &quot; + currentFile.getFileName());</span>
<span class="nc" id="L911">                Files.copy(tarStream, currentFile, StandardCopyOption.REPLACE_EXISTING);</span>
<span class="nc" id="L912">            }</span>
<span class="nc" id="L913">        } catch (IOException e) {</span>
<span class="nc" id="L914">            getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L915">        }</span>

        try {
<span class="nc bnc" id="L918" title="All 2 branches missed.">            if (currentFile != null) {</span>
                // Extract Portable Git
<span class="nc" id="L920">                getLog().debug(&quot;Extract Portable Git&quot;);</span>
<span class="nc" id="L921">                execute(Arrays.asList(currentFile.toString(), &quot;-y&quot;, &quot;-o&quot;, location), !ATTACH_ARTIFACT);</span>
<span class="nc" id="L922">                gitPath = location + GIT_USER_BIN;</span>
            }
<span class="nc" id="L924">        } catch (IOException e) {</span>
<span class="nc" id="L925">            getLog().error(&quot;&quot;, e);</span>
<span class="nc" id="L926">        } catch (InterruptedException e) {</span>
<span class="nc" id="L927">            getLog().error(&quot;&quot;, e);</span>
            // restore interruption status of the corresponding thread
<span class="nc" id="L929">            Thread.currentThread().interrupt();</span>
<span class="nc" id="L930">        }</span>
<span class="nc" id="L931">    }</span>

    private void setFilePermissions(File file) {
<span class="nc bnc" id="L934" title="All 2 branches missed.">        if (!file.setExecutable(true, true)) {</span>
<span class="nc" id="L935">            getLog().error(String.join(&quot; &quot;, &quot;Unable to set executable:&quot;, file.getName()));</span>
        } else {
<span class="nc" id="L937">            getLog().debug(String.join(&quot; &quot;, &quot;Set executable for&quot;, file.getName()));</span>
        }
<span class="nc" id="L939">    }</span>

    private void setPosixFilePermissions(Path path) {
<span class="nc" id="L942">        final Set&lt;PosixFilePermission&gt; permissions = PosixFilePermissions.fromString(PERMISSIONS);</span>

        try {
<span class="nc" id="L945">            Files.setPosixFilePermissions(path, permissions);</span>
<span class="nc" id="L946">            getLog().debug(String.join(&quot; &quot;, &quot;Set Posix File Permissions for&quot;, path.toString(), &quot;as&quot;, PERMISSIONS));</span>
<span class="nc" id="L947">        } catch (IOException e) {</span>
<span class="nc" id="L948">            getLog().error(&quot;Failed attempted Posix permissions&quot;, e);</span>
<span class="nc" id="L949">        } catch (UnsupportedOperationException e) {</span>
            // Attempting but don't care about status if it fails
<span class="nc" id="L951">            getLog().debug(&quot;Failed attempted Posix permissions&quot;, e);</span>
<span class="nc" id="L952">        }</span>
<span class="nc" id="L953">    }</span>

    /**
     * Load args.
     *
     * @return the string
     */
    private List&lt;String&gt; loadArgs() {
<span class="nc" id="L961">        getLog().debug(&quot;Loading arguments&quot;);</span>

<span class="nc" id="L963">        List&lt;String&gt; args = new ArrayList&lt;&gt;(50);</span>

        // &quot; --tar-quietly : Suppress verbose output from the tar command&quot;
<span class="nc bnc" id="L966" title="All 2 branches missed.">        if (isTrue(tarQuietly)) {</span>
<span class="nc" id="L967">            args.add(&quot;--tar-quietly&quot;);</span>
        }

        // &quot; --quiet | -q : Do not print any messages other than errors.&quot;
<span class="nc bnc" id="L971" title="All 2 branches missed.">        if (isTrue(quiet)) {</span>
<span class="nc" id="L972">            args.add(&quot;--quiet&quot;);</span>
        }

        // --gzip : Use gzip for compression (the default on platforms on which gzip is commonly available, like Linux)
<span class="nc bnc" id="L976" title="All 2 branches missed.">        if (isTrue(gzip)) {</span>
<span class="nc" id="L977">            args.add(&quot;--gzip&quot;);</span>
        }

        // --bzip2 : Use bzip2 instead of gzip for better compression. The bzip2 command must be available in the
        // command path. It is recommended that the archive prefix be set to something like '.bz2.run', so that
        // potential users know that they'll need bzip2 to extract it.
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (isTrue(bzip2)) {</span>
<span class="nc" id="L984">            args.add(&quot;--bzip2&quot;);</span>
        }

        // --bzip3 : Use bzip3 instead of gzip for better compression. The bzip3 command must be available in the
        // command path. It is recommended that the archive prefix be set to something like '.bz3.run', so that
        // potential users know that they'll need bzip3 to extract it.
<span class="nc bnc" id="L990" title="All 2 branches missed.">        if (isTrue(bzip3)) {</span>
<span class="nc" id="L991">            args.add(&quot;--bzip3&quot;);</span>
        }

        // --pbzip2 : Use pbzip2 instead of gzip for better and faster compression on machines having multiple CPUs.
        // The pbzip2 command must be available in the command path. It is recommended that the archive prefix be
        // set to something like '.pbz2.run', so that potential users know that they'll need bzip2 to extract it.
<span class="nc bnc" id="L997" title="All 2 branches missed.">        if (isTrue(pbzip2)) {</span>
<span class="nc" id="L998">            args.add(&quot;--pbzip2&quot;);</span>
        }

        // --xz : Use xz instead of gzip for better compression. The xz command must be available in the command path.
        // It is recommended that the archive prefix be set to something like '.xz.run' for the archive, so that
        // potential users know that they'll need xz to extract it.
<span class="nc bnc" id="L1004" title="All 2 branches missed.">        if (isTrue(xz)) {</span>
<span class="nc" id="L1005">            args.add(&quot;--xz&quot;);</span>
        }

        // --lzo : Use lzop instead of gzip for better compression. The lzop command must be available in the command
        // path. It is recommended that the archive prefix be set to something like '.lzo.run' for the archive, so
        // that potential users know that they'll need lzop to extract it.
<span class="nc bnc" id="L1011" title="All 2 branches missed.">        if (isTrue(lzo)) {</span>
<span class="nc" id="L1012">            args.add(&quot;--lzo&quot;);</span>
        }

        // --lz4 : Use lz4 instead of gzip for better compression. The lz4 command must be available in the command
        // path. It is recommended that the archive prefix be set to something like '.lz4.run' for the archive, so
        // that potential users know that they'll need lz4 to extract it.
<span class="nc bnc" id="L1018" title="All 2 branches missed.">        if (isTrue(lz4)) {</span>
<span class="nc" id="L1019">            args.add(&quot;--lz4&quot;);</span>
        }

        // --zstd : Use zstd for compression.
<span class="nc bnc" id="L1023" title="All 2 branches missed.">        if (isTrue(zstd)) {</span>
<span class="nc" id="L1024">            args.add(&quot;--zstd&quot;);</span>
        }

        // --pigz : Use pigz for compression.
<span class="nc bnc" id="L1028" title="All 2 branches missed.">        if (isTrue(pigz)) {</span>
<span class="nc" id="L1029">            args.add(&quot;--pigz&quot;);</span>
        }

        // --base64 : Encode the archive to ASCII in Base64 format (base64 command required).
<span class="nc bnc" id="L1033" title="All 2 branches missed.">        if (isTrue(base64)) {</span>
<span class="nc" id="L1034">            args.add(&quot;--base64&quot;);</span>
        }

        // --gpg-encrypt : Encrypt the archive using gpg -ac -z $COMPRESS_LEVEL. This will prompt for a password to
        // encrypt with. Assumes that potential users have gpg installed.
<span class="nc bnc" id="L1039" title="All 2 branches missed.">        if (isTrue(gpgEncrypt)) {</span>
<span class="nc" id="L1040">            args.add(&quot;--gpg-encrypt&quot;);</span>
        }

        // --gpg-asymmetric-encrypt-sign : Instead of compressing, asymmetrically encrypt and sign the data using GPG
<span class="nc bnc" id="L1044" title="All 2 branches missed.">        if (isTrue(gpgAsymmetricEncryptSign)) {</span>
<span class="nc" id="L1045">            args.add(&quot;--gpg-asymmetric-encrypt-sign&quot;);</span>
        }

        // --ssl-encrypt : Encrypt the archive using openssl aes-256-cbc -a -salt. This will prompt for a password to
        // encrypt with. Assumes that the potential users have the OpenSSL tools installed.
<span class="nc bnc" id="L1050" title="All 2 branches missed.">        if (isTrue(sslEncrypt)) {</span>
<span class="nc" id="L1051">            args.add(&quot;--ssl-encrypt&quot;);</span>
        }

        // --ssl-passwd pass : Use the given password to encrypt the data using OpenSSL.
<span class="nc bnc" id="L1055" title="All 2 branches missed.">        if (sslPasswd != null) {</span>
<span class="nc" id="L1056">            args.add(&quot;--ssl-passwd&quot;);</span>
<span class="nc" id="L1057">            args.add(sslPasswd);</span>
        }

        // --ssl-pass-src src : Use the given src as the source of password to encrypt the data using OpenSSL. See
        // \&quot;PASS PHRASE ARGUMENTS\&quot; in man openssl. If this option is not supplied, the user wil be asked to enter
        // encryption pasword on the current terminal.
<span class="nc bnc" id="L1063" title="All 2 branches missed.">        if (sslPassSrc != null) {</span>
<span class="nc" id="L1064">            args.add(&quot;--ssl-pass-src&quot;);</span>
<span class="nc" id="L1065">            args.add(sslPassSrc);</span>
        }

        // --ssl-no-md : Do not use \&quot;-md\&quot; option not supported by older OpenSSL.
<span class="nc bnc" id="L1069" title="All 2 branches missed.">        if (isTrue(sslNoMd)) {</span>
<span class="nc" id="L1070">            args.add(&quot;--ssl-no-md&quot;);</span>
        }

        // --compress : Use the UNIX compress command to compress the data. This should be the default on all platforms
        // that don't have gzip available.
<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (isTrue(compress)) {</span>
<span class="nc" id="L1076">            args.add(&quot;--compress&quot;);</span>
        }

        // --complevel : Specify the compression level for gzip, bzip2, bzip3, pbzip2, xz, lzo or lz4. (defaults to 9)
<span class="nc bnc" id="L1080" title="All 2 branches missed.">        if (complevel != null) {</span>
<span class="nc" id="L1081">            args.add(&quot;--complevel&quot;);</span>
<span class="nc" id="L1082">            args.add(complevel.toString());</span>
        }

        // --comp-extra : Append extra options to the chosen compressor&quot;
<span class="nc bnc" id="L1086" title="All 2 branches missed.">        if (compExtra != null) {</span>
<span class="nc" id="L1087">            args.add(&quot;--comp-extra&quot;);</span>
<span class="nc" id="L1088">            args.add(compExtra);</span>
        }

        // --nochown : Do not give the target folder to the current user (default)
<span class="nc bnc" id="L1092" title="All 2 branches missed.">        if (isTrue(nochown)) {</span>
<span class="nc" id="L1093">            args.add(&quot;--nochown&quot;);</span>
        }

        // --chown : Give the target folder to the current user recursively.
<span class="nc bnc" id="L1097" title="All 2 branches missed.">        if (isTrue(chown)) {</span>
<span class="nc" id="L1098">            args.add(&quot;--chown&quot;);</span>
        }

        // --nocomp : Do not use any compression for the archive, which will then be an uncompressed TAR.
<span class="nc bnc" id="L1102" title="All 2 branches missed.">        if (isTrue(nocomp)) {</span>
<span class="nc" id="L1103">            args.add(&quot;--nocomp&quot;);</span>
        }

        // --threads thds : Number of threads to be used by compressors that support parallelization.
        // Omit to use compressor's default. Most useful (and required) for opting into xz's threading,
        // usually with '--threads=0' for all available cores.pbzip2 and pigz are parallel by default,
        // and setting this value allows limiting the number of threads they use.
<span class="nc bnc" id="L1110" title="All 2 branches missed.">        if (threads != null) {</span>
<span class="nc" id="L1111">            args.add(&quot;--threads&quot;);</span>
<span class="nc" id="L1112">            args.add(threads.toString());</span>
        }

        // --notemp : The generated archive will not extract the files to a temporary directory, but in a new directory
        // created in the current directory. This is better to distribute software packages that may extract and compile
        // by themselves (i.e. launch the compilation through the embedded script).
<span class="nc bnc" id="L1118" title="All 2 branches missed.">        if (isTrue(notemp)) {</span>
<span class="nc" id="L1119">            args.add(&quot;--notemp&quot;);</span>
        }

        // --needroot : Check that the root user is extracting the archive before proceeding
<span class="nc bnc" id="L1123" title="All 2 branches missed.">        if (isTrue(needroot)) {</span>
<span class="nc" id="L1124">            args.add(&quot;--needroot&quot;);</span>
        }

        // --current : Files will be extracted to the current directory, instead of in a sub-directory. This option
        // implies --notemp and does not require a startup_script.
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        if (isTrue(current)) {</span>
<span class="nc" id="L1130">            args.add(&quot;--current&quot;);</span>
        }

        // --follow : Follow the symbolic links inside of the archive directory, i.e. store the files that are being
        // pointed to instead of the links themselves.
<span class="nc bnc" id="L1135" title="All 2 branches missed.">        if (isTrue(follow)) {</span>
<span class="nc" id="L1136">            args.add(&quot;--follow&quot;);</span>
        }

        // --noprogress : Do not show the progress during the decompression
<span class="nc bnc" id="L1140" title="All 2 branches missed.">        if (isTrue(noprogress)) {</span>
<span class="nc" id="L1141">            args.add(&quot;--noprogress&quot;);</span>
        }

        // --append (new in 2.1.x): Append data to an existing archive, instead of creating a new one. In this mode, the
        // settings from the original archive are reused (compression type, label, embedded script), and thus don't need
        // to be specified again on the command line.
<span class="nc bnc" id="L1147" title="All 2 branches missed.">        if (isTrue(append)) {</span>
<span class="nc" id="L1148">            args.add(&quot;--append&quot;);</span>
        }

        // --header : Makeself 2.0 uses a separate file to store the header stub, called makeself-header.sh. By default,
        // it is assumed that it is stored in the same location as makeself.sh. This option can be used to specify its
        // actual location if it is stored someplace else.
<span class="nc bnc" id="L1154" title="All 2 branches missed.">        if (headerFile != null) {</span>
<span class="nc" id="L1155">            args.add(&quot;--header&quot;);</span>
<span class="nc" id="L1156">            args.add(headerFile);</span>
        }

        // --preextract : Specify a pre-extraction script. The script is executed with the same environment and initial
        // `script_args` as `startup_script`.
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (preextractScript != null) {</span>
<span class="nc" id="L1162">            args.add(&quot;--reextract&quot;);</span>
<span class="nc" id="L1163">            args.add(preextractScript);</span>
        }

        // --cleanup : Specify a script that is run when execution is interrupted or finishes successfully. The script
        // is executed with the same environment and initial `script_args` as `startup_script`.
<span class="nc bnc" id="L1168" title="All 2 branches missed.">        if (cleanupScript != null) {</span>
<span class="nc" id="L1169">            args.add(&quot;--cleanup&quot;);</span>
<span class="nc" id="L1170">            args.add(cleanupScript);</span>
        }

        // --copy : Upon extraction, the archive will first extract itself to a temporary directory. The main
        // application of this is to allow self-contained installers stored in a Makeself archive on a CD, when the
        // installer program will later need to unmount the CD and allow a new one to be inserted. This prevents
        // &quot;File system busy&quot; errors for installers that span multiple CDs.
<span class="nc bnc" id="L1177" title="All 2 branches missed.">        if (isTrue(copy)) {</span>
<span class="nc" id="L1178">            args.add(&quot;--copy&quot;);</span>
        }

        // --nox11 : Disable the automatic spawning of a new terminal in X11.
<span class="nc bnc" id="L1182" title="All 2 branches missed.">        if (isTrue(nox11)) {</span>
<span class="nc" id="L1183">            args.add(&quot;--nox11&quot;);</span>
        }

        // --nowait : When executed from a new X11 terminal, disable the user prompt at the end of the script execution.
<span class="nc bnc" id="L1187" title="All 2 branches missed.">        if (isTrue(nowait)) {</span>
<span class="nc" id="L1188">            args.add(&quot;--nowait&quot;);</span>
        }

        // --nomd5 : Disable the creation of a MD5 checksum for the archive. This speeds up the extraction process if
        // integrity checking is not necessary.
<span class="nc bnc" id="L1193" title="All 2 branches missed.">        if (isTrue(nomd5)) {</span>
<span class="nc" id="L1194">            args.add(&quot;--nomd5&quot;);</span>
        }

        // --nocrc : Disable the creation of a CRC checksum for the archive. This speeds up the extraction process if
        // integrity checking is not necessary.
<span class="nc bnc" id="L1199" title="All 2 branches missed.">        if (isTrue(nocrc)) {</span>
<span class="nc" id="L1200">            args.add(&quot;--nocrc&quot;);</span>
        }

        // --sha256 : Compute a SHA256 checksum for the archive.
<span class="nc bnc" id="L1204" title="All 2 branches missed.">        if (isTrue(sha256)) {</span>
<span class="nc" id="L1205">            args.add(&quot;--sha256&quot;);</span>
        }

        // --lsm file : Provide and LSM file to makeself, that will be embedded in the generated archive. LSM files are
        // describing a software package in a way that is easily parseable. The LSM entry can then be later retrieved
        // using the --lsm argument to the archive. An example of a LSM file is provided
        // with Makeself.
<span class="nc bnc" id="L1212" title="All 2 branches missed.">        if (lsmFile != null) {</span>
<span class="nc" id="L1213">            args.add(&quot;--lsm&quot;);</span>
<span class="nc" id="L1214">            args.add(lsmFile);</span>
        }

        // --gpg-extra opt : Append more options to the gpg command line.
<span class="nc bnc" id="L1218" title="All 2 branches missed.">        if (gpgExtraOpt != null) {</span>
<span class="nc" id="L1219">            args.add(&quot;--gpg-extra&quot;);</span>
<span class="nc" id="L1220">            args.add(gpgExtraOpt);</span>
        }

        // --tar-format opt : Specify the tar archive format (default is ustar); you may use any value accepted by your
        // tar command (such as posix, v7, etc).
<span class="nc bnc" id="L1225" title="All 2 branches missed.">        if (tarFormatOpt != null) {</span>
<span class="nc" id="L1226">            args.add(&quot;--tar-format&quot;);</span>
<span class="nc" id="L1227">            args.add(tarFormatOpt);</span>
        }

        // --tar-extra opt : Append more options to the tar command line.
        // For instance, in order to exclude the .git directory from the packaged archive directory using the GNU tar,
        // one can use makeself.sh --tar-extra &quot;--exclude=.git&quot; ...
<span class="nc bnc" id="L1233" title="All 2 branches missed.">        if (tarExtraOpt != null) {</span>
<span class="nc" id="L1234">            args.add(&quot;--tar-extra&quot;);</span>
<span class="nc" id="L1235">            args.add(tarExtraOpt);</span>
        }

        // --untar-extra opt : Append more options to the during the extraction of the tar archive.
<span class="nc bnc" id="L1239" title="All 2 branches missed.">        if (untarExtraOpt != null) {</span>
<span class="nc" id="L1240">            args.add(&quot;--untar-extra&quot;);</span>
<span class="nc" id="L1241">            args.add(untarExtraOpt);</span>
        }

        // --sign passphrase : Signature private key to sign the package with
<span class="nc bnc" id="L1245" title="All 2 branches missed.">        if (signPassphrase != null) {</span>
<span class="nc" id="L1246">            args.add(&quot;--sign&quot;);</span>
<span class="nc" id="L1247">            args.add(signPassphrase);</span>
        }

        // --target dir : Specify the directory where the archive will be extracted. This option implies
        // --notemp and does not require a startup_script.
<span class="nc bnc" id="L1252" title="All 2 branches missed.">        if (extractTargetDir != null) {</span>
<span class="nc" id="L1253">            args.add(&quot;--target&quot;);</span>
<span class="nc" id="L1254">            args.add(extractTargetDir);</span>
        }

        // --keep-umask : Keep the umask set to shell default, rather than overriding when executing self-extracting
        // archive.
<span class="nc bnc" id="L1259" title="All 2 branches missed.">        if (isTrue(keepUmask)) {</span>
<span class="nc" id="L1260">            args.add(&quot;--keep-umask&quot;);</span>
        }

        // --export-conf : Export configuration variables to startup_script&quot;
<span class="nc bnc" id="L1264" title="All 2 branches missed.">        if (isTrue(exportConf)) {</span>
<span class="nc" id="L1265">            args.add(&quot;--export-conf&quot;);</span>
        }

        // --packaging-date date : Use provided string as the packaging date instead of the current date.
<span class="nc bnc" id="L1269" title="All 2 branches missed.">        if (packagingDate != null) {</span>
<span class="nc" id="L1270">            args.add(&quot;--packaging-date&quot;);</span>
<span class="nc" id="L1271">            args.add(packagingDate);</span>
        }

        // --license : Append a license file.
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (licenseFile != null) {</span>
<span class="nc" id="L1276">            args.add(&quot;--license&quot;);</span>
<span class="nc" id="L1277">            args.add(licenseFile);</span>
        }

        // --nooverwrite : Do not extract the archive if the specified target directory already exists.
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        if (isTrue(nooverwrite)) {</span>
<span class="nc" id="L1282">            args.add(&quot;--nooverwrite&quot;);</span>
        }

        // --help-header file : Add a header to the archive's --help output.
<span class="nc bnc" id="L1286" title="All 2 branches missed.">        if (helpHeaderFile != null) {</span>
<span class="nc" id="L1287">            args.add(&quot;--help-header&quot;);</span>
<span class="nc" id="L1288">            args.add(helpHeaderFile);</span>
        }

<span class="nc" id="L1291">        return args;</span>
    }

    private boolean isTrue(Boolean value) {
<span class="nc bnc" id="L1295" title="All 2 branches missed.">        if (value != null) {</span>
<span class="nc" id="L1296">            return value.booleanValue();</span>
        }
<span class="nc" id="L1298">        return false;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>